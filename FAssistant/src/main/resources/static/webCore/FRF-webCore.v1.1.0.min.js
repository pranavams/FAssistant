/**
	 * @ngdoc overview
	 * @name WebCoreModule
	 * @description
	 * WebCore is a collection of internally developed components and extensions and is the majority of the custom code developed for the
	 * Ford Responsive Framework (FRF). The WebCoreModule includes all needed vendor scripts as dependencies and also includes the custom
	 * developed scripts. Applications can take advantage of all vendor and custom code via inclusion of WebCoreModule.
	 */
"use strict";angular.module("WebCoreModule",["pascalprecht.translate","ui.router","ngTouch","ui.bootstrap","ui.mask","ui.select","WcResponsiveTableModule"]).config(["$httpProvider",function($httpProvider){
//override default $http behavior to trigger any webCore http requests to be batched into similar digest cycles.
$httpProvider.useApplyAsync(!0)}]),/**
	 * @ngdoc service
	 * @name WebCoreModule.service:_
	 * @description
	 * WebCore includes the underscore library. Since it's not defined in the Angular context, we define an Angular constant for it here.
	 */
angular.module("WebCoreModule").constant("_",window._),/**
	 * @ngdoc service
	 * @name WebCoreModule.service:Constants
	 * @description
	 * WebCore includes a few constant values that are applicable module-wide. They are defined here as a constant service for use
	 * throughout the module.
	 */
angular.module("WebCoreModule").constant("Constants",{local:"local",wslBaseUrl:"https://www.wsl.ford.com/login.cgi?portstripping=no&back=",authorization:{any:"Any",all:"All"},version:"Ford Responsive Framework (FRF) 1.1.0"}),jQuery.fn.exists=function(){return 0!==this.length},jQuery.fn.outerHTML=function(){return jQuery("<div>").append(this.eq(0).clone()).html()},
//credit to stack overflow posters 'Michael Herold and Ryan O'Neill': http://stackoverflow.com/a/15311842
angular.merge=function(dst){return angular.forEach(arguments,function(obj){obj!==dst&&angular.forEach(obj,function(value,key){dst[key]&&dst[key].constructor&&dst[key].constructor===Object?angular.merge(dst[key],value):dst[key]=value})}),dst},angular.module("WebCoreModule").service("WcAlertConsoleService",["$timeout","_","$interval","$sce",function($timeout,_,$interval,$sce){/**
		 * @ngdoc method
		 * @name WcAlertConsoleService.configureDefaults
		 * @methodOf WebCoreModule.service:WcAlertConsoleService
		 * @param {Object} config Options object to configure default values used by the WcAlertConsoleService. Config properties that can be set in this object include:
		 *  - visible: set to true to make the messages visible (default). Set to false to hide the messages in the console.
		 *  - multiple: set to true to allow multiple copies of the same message in the console (default). Set to false to allow only a single copy to be displayed in the console.
		 *  - persist: set to false to allow the messages to be cleared from the console (default). Set to true to make the messages persist in the console.
		 *  - timeout: set an integer value for the length of time in seconds a message should stay in the console. (default, 7sec)
		 *  - errorOnStateChange: set to true to have messages removed when a state change occurs (default). Set to false to allow the messages to stay in the console across states.
		 * @description
		 * The WcAlertConsoleService configures itself with application-wide defaults when it starts up. The configureDefaults function allows
		 * you to override those defaults at the app level, so that the new parameters will apply to any message added to the console.
		 */
this.configureDefaults=function(config){config&&(void 0===config.visible||config.visible!==!0&&config.visible!==!1||(visibleDefault=config.visible),void 0===config.multiple||config.multiple!==!0&&config.multiple!==!1||(multipleDefault=config.multiple),void 0===config.persist||config.persist!==!0&&config.persist!==!1||(persistDefault=config.persist),void 0!==config.timeout&&"NaN"!=parseInt(config.timeout)&&(timeoutDefault=config.timeout),!config.errorOnStateChange||config.errorOnStateChange!==!0&&config.errorOnStateChange!==!1||(removeErrorOnStateChange=config.errorOnStateChange))};var visibleDefault=!0,multipleDefault=!0,persistDefault=!1,timeoutDefault=7,fadeOutAnimationLengthMS=350,removeErrorOnStateChange=!0;this.getSettings=function(){var settings={visible:visibleDefault,multiple:multipleDefault,persist:persistDefault,timeout:timeoutDefault,fadeOutAnimationLengthMS:fadeOutAnimationLengthMS,removeErrorOnStateChange:removeErrorOnStateChange};return settings};var messages=[];this.isMessageDuplicate=function(msg){for(var isDuplicate=!1,i=0;i<messages.length;i++)messages[i].message.$$unwrapTrustedValue()===msg.$$unwrapTrustedValue()&&(isDuplicate=!0);return isDuplicate},/**
		 * @ngdoc method
		 * @name WcAlertConsoleService.addMessage
		 * @methodOf WebCoreModule.service:WcAlertConsoleService
		 * @param {Object} messageInstance Object to configure the message to add to the console. Config properties that can be set in this object include:
		 *  - message: Required. The string of text that will be added to the console as a message.
		 *  - type: Required. The type of message styling to apply. Can be success, info, warning, or danger.
		 *  - visible: set to true to make the messages visible (default). Set to false to hide the messages in the console.
		 *  - multiple: set to true to allow multiple copies of the same message in the console (default). Set to false to allow only a single copy to be displayed in the console.
		 *  - persist: set to false to allow the messages to be cleared from the console (default). Set to true to make the messages persist in the console.
		 *  - timeout: set an integer value for the length of time in seconds a message should stay in the console. (default, 7sec)
		 *  - errorOnStateChange: set to true to have messages removed when a state change occurs (default). Set to false to allow the messages to stay in the console across states.
		 * @description
		 * The WcAlertConsoleService allows you to add messages to the alert console by leveraging the addMessage function.
		 * Messages will assume all app-wide configuration defaults, but those defaults can be overridden here by passing in the new configuration as a part of the messageInstance object.
		 */
this.addMessage=function(messageInstance){
//first, trust the alert text as html
messageInstance.message=$sce.trustAsHtml(messageInstance.message),messageInstance&&(void 0===messageInstance.visible&&(messageInstance.visible=visibleDefault),void 0===messageInstance.multiple&&(messageInstance.multiple=multipleDefault),void 0===messageInstance.persist&&(messageInstance.persist=persistDefault),void 0===messageInstance.timeout&&(messageInstance.timeout=timeoutDefault));
// create identifier for message
var uniqueishID=_.uniqueId("alert_");messageInstance.uniqueishID=uniqueishID,"danger"===messageInstance.type&&(messageInstance.persist=!0),
// prevent duplicate message if multiple=false
messageInstance.multiple===!1?this.isMessageDuplicate(messageInstance.message)||messages.push(messageInstance):messages.push(messageInstance),messageInstance.persist===!1&&($interval(function(){for(var f=0;f<messages.length;f++)messages[f].uniqueishID===messageInstance.uniqueishID&&(messages[f].fadeOut=!0)},1e3*messageInstance.timeout-fadeOutAnimationLengthMS,1),$interval(angular.bind(this,function(){this.removeMessage(messageInstance.uniqueishID)}),1e3*messageInstance.timeout,1),$interval(angular.bind(this,function(){this.updateTimeout(messageInstance.uniqueishID)}),1e3,messageInstance.timeout))},this.updateTimeout=function(uniqueishID){for(var i=0;i<messages.length;i++)messages[i].uniqueishID===uniqueishID&&messages[i].timeout--},
// removes a specific message
this.removeMessage=function(uniqueishID,manualFade){function foo(uniqueishID){return function(){this.removeMessage(uniqueishID)}}for(var i in messages)if(messages[i].uniqueishID===uniqueishID)return manualFade?(messages[i].fadeOut=!0,void $timeout(angular.bind(this,foo(uniqueishID)),fadeOutAnimationLengthMS)):void messages.splice(i,1)},
// removes all messages (includingPersistent - set to true to remove persistent msg)
this.removeMessages=function(includingPersistent){for(var i=0;i<messages.length;i++)messages[i].persist!==!1&&includingPersistent!==!0||(messages.splice(i,1),
// reset index for accurate loop
i-=1)},this.removeErrorMessages=function(){for(var i=0;i<messages.length;i++)"danger"===messages[i].type&&(messages.splice(i,1),
// reset index for accurate loop
i-=1)},
// returns all messages (onlyVisible to only get visible messages)
this.getMessages=function(onlyVisible){for(var messagesToReturn=[],i=0;i<messages.length;i++)(onlyVisible===!0&&messages[i].visible===!0||void 0===onlyVisible)&&messagesToReturn.push(messages[i]);return messagesToReturn},
// returns messages that match specific type
this.getMessagesByType=function(typeToMatch){for(var messagesToReturn=[],i=0;i<messages.length;i++)messages[i].type===typeToMatch&&messagesToReturn.push(messages[i]);return messagesToReturn}}]),angular.module("WebCoreModule").service("WcAuthorizationCacheHelper",["_","$q","$window",function(_,$q,$window){/**
			Policy Cache Format
			[
				{
					"policy":"DeleteBooking:execute",
					"authorized":false
				}
			]

			requestedPolicies Format
			[
				'resource:action',
				'resource:action',
				'resource:action'
			]
		**/
this.setSessionCache=function(){$window.sessionStorage.policyCache=angular.toJson(this.cache)},this.getSessionCache=function(){return angular.fromJson($window.sessionStorage.policyCache)},this.cache=this.getSessionCache(),this.cache||(this.cache=[]),this.resetCache=function(){this.cache=[]},this.retrievePolicyAuthorization=function(formattedPolicy){var foundPolicy=_.findWhere(this.cache,{policy:formattedPolicy});return void 0!==foundPolicy?foundPolicy.promise&&foundPolicy.promise.then?foundPolicy.promise.then(function(resolved){return resolved=resolved.data?resolved.data:resolved,resolved.authorized}):$q.when(foundPolicy.authorized):null},this.formatPolicy=function(name,promiseOrData){
// detect if policy is a promise
if(promiseOrData.then){promiseOrData.then(angular.bind(this,function(resolvedPolicy){var policyLocation;for(policyLocation=0;policyLocation<this.cache.length&&this.cache[policyLocation].policy!=name;policyLocation++);resolvedPolicy=resolvedPolicy.data?resolvedPolicy.data:resolvedPolicy,this.cache[policyLocation]=this.formatPolicy(name,resolvedPolicy),this.setSessionCache()}));var cachePolicy={};return cachePolicy.policy=name,cachePolicy.promise=promiseOrData,cachePolicy}var localPolicy=angular.copy(promiseOrData);return localPolicy.policy=name,delete localPolicy.resource,delete localPolicy.action,localPolicy},this.addPolicy=function(policyName,policyPromise){this.cache.push(this.formatPolicy(policyName,policyPromise)),this.setSessionCache()}}]),angular.module("WebCoreModule").service("WcAuthorizationService",["WcHttpEndpointPrototype","WcAuthorizationCacheHelper","_","$q","Constants","$state",function(WcHttpEndpointPrototype,WcAuthorizationCacheHelper,_,$q,Constants,$state){this.authorizationEndpoint=new WcHttpEndpointPrototype("authorization"),this.requestAuthorization=function(name){WcAuthorizationCacheHelper.addPolicy(name,this.authorizationEndpoint.get({params:{authorizationString:name}}).then(function(response){return response.data[0]}))},this.isAuthorizedFromCache=function(policy){return WcAuthorizationCacheHelper.retrievePolicyAuthorization(policy)},/**
		 * @ngdoc method
		 * @name WcAuthorizationService.isStateAuthorized
		 * @methodOf WebCoreModule.service:WcAuthorizationService
		 * @param {String} stateName String identifying the state to check the user's authoization for.
		 * @returns {Promise} Promise object containing the results of the authorization check for the given state's policies.
		 * @description
		 * The isStateAuthorized function is a wrapper for the isAuthorized call when working with states. The function will
		 * find the authorization policies associated with the given state name and invoke isAuthorized to determine if the
		 * user is authorized to access the state.
		 */
this.isStateAuthorized=function(stateName){
// Grab applicable policies from state's definition
var state=$state.get(stateName),policies=null,criteria=null;
// If state does not require any policy permissions, return true.
// If state does not require any policy permissions, return true.
// Set criteria to 'All' by default if not specified
return state.data&&(policies=state.data.policies?state.data.policies:null,criteria=state.data.criteria?state.data.criteria:null),policies?(policies&&!criteria&&(criteria=Constants.authorization.all),this.isAuthorized(policies,criteria)):$q.when(!0)},/**
		 * @ngdoc method
		 * @name WcAuthorizationService.isAuthorized
		 * @methodOf WebCoreModule.service:WcAuthorizationService
		 * @param {String|Array} policySet Set of policies to check authorization against.
		 * @param {String} criteria String identifying if the check should be for authorization against any or all of the policies.
		 * @returns {Promise} Promise object containing the results of the authorization check for the given policySet and criteria.
		 * @description
		 * The isAuthorized function checks if the current user is authorized for the given policy set. Checks are made via
		 * restful communications to the application server. The authorization service caches responses, to limit network
		 * traffic if multiple checks are required for the same policy. The function returns a promise that will resolve based
		 * on the given criteria. If 'All' is specified, the promise will be true if the user is authorized for all policies.
		 * If 'Any' is specified, the promise will be true if the user is authorized for any of the policies.
		 */
this.isAuthorized=function(policySet,criteria){criteria||(criteria=Constants.authorization.all),angular.isArray(policySet)||(policySet=[policySet]);var authorizations=[];return _.each(policySet,angular.bind(this,function(policy){var isCached=this.isAuthorizedFromCache(policy);null===isCached&&(this.requestAuthorization(policy),isCached=this.isAuthorizedFromCache(policy)),authorizations.push(isCached)})),$q.all(authorizations).then(function(arrayOfAuths){switch(criteria){case"Any":return _.some(arrayOfAuths);case"All":return _.every(arrayOfAuths);default:return!1}})}}]),angular.module("WebCoreModule").service("WcCameraService",["$window","$rootScope","WcImageFileService",function($window,$rootScope,WcImageFileService){var navigator=$window.navigator;
//Events to ensure Webcam is disengaged when navigated away.
$rootScope.$on("$stateChangeStart",angular.bind(this,function(){this.stopCamera()})),$window.onbeforeunload=angular.bind(this,function(){this.stopCamera()}),this.cameraIsOn=!1,this.height=0,this.width=0,this.setCameraSize=function(x,y){this.height=y,this.width=x},
// WebcamJS's solution for finding the correct getUserMedia function
// https://github.com/jhuckaby/webcamjs/blob/master/webcam.js
this.mediaDevices=navigator.mediaDevices&&navigator.mediaDevices.getUserMedia?navigator.mediaDevices:navigator.mozGetUserMedia||navigator.webkitGetUserMedia?{getUserMedia:function(c){
// TODO use $q
return new Promise(function(y,n){(navigator.mozGetUserMedia||navigator.webkitGetUserMedia).call(navigator,c,y,n)})}}:null,
//end webcamjs
// Only for testing. We have yet to find out how to mock document.createElement without
// blowing up angular-mock. We have a Stack Overflow question out there to hopefully
// find an answer.
//
// TODO: try $document instead of document
// http://stackoverflow.com/questions/35369629/using-jasmine-to-spy-on-document-createelement-throws-error-from-angular-mock
//
this.generateVideo=function(){return document.createElement("video")},
// https://github.com/jhuckaby/webcamjs/blob/master/webcam.js
this.returnVideoElement=function(){
// We don't use jQuery for the video element because you must call the play() function
// on the actual HTML element, not a jquery object.
return this.videoElement=this.generateVideo(),this.videoElement.setAttribute("autoplay","autoplay"),this.videoElement.style.width=""+this.width+"px",this.videoElement.style.height=""+this.height+"px",this.mediaDevices.getUserMedia({audio:!1,video:!0}).then(angular.bind(this,function(stream){return this.stream=stream,this.videoElement.src=$window.URL.createObjectURL(stream),$(this.videoElement)}))["catch"](function(error){console.error(error)})},
//end webcamjs
/**
			 * @ngdoc method
			 * @name WcCameraService.checkForCamera
			 * @methodOf WebCoreModule.service:WcCameraService
			 * @returns {Promise} The data retrieved from the backing service wrapped in a promise.
			 * @description
			 * The WcCameraService provides a checkForCamera function to check the availability of the user's camera.
			 */
this.checkForCamera=function(){return $window.navigator.mediaDevices.enumerateDevices().then(function(devices){return devices=devices.filter(function(device){return"videoinput"===device.kind}),devices.length>0})["catch"](function(err){console.log(err.name+": "+err.message)})},/**
			 * @ngdoc method
			 * @name WcCameraService.takePicture
			 * @methodOf WebCoreModule.service:WcCameraService
			 * @returns {Object} The data retrieved from the backing service will be an image in jpeg format.
			 * @description
			 * The WcCameraService provides a takePicture function to take the picture from user's camera.
			 */
this.takePicture=function(){var canvas=WcImageFileService.generateCanvas();canvas.width=this.width,canvas.height=this.height;var context=canvas.getContext("2d");return context.drawImage(this.videoElement,0,0,this.width,this.height),canvas.toDataURL("image/jpeg",100)},/**
			 * @ngdoc method
			 * @name WcCameraService.startCamera
			 * @methodOf WebCoreModule.service:WcCameraService
			 * @description
			 * The WcCameraService provides an stopCamera function to start the camera.
			 */
this.startCamera=function(){this.videoElement.play(),this.cameraIsOn=!0},/**
			 * @ngdoc method
			 * @name WcCameraService.stopCamera
			 * @methodOf WebCoreModule.service:WcCameraService
			 * @description
			 * The WcCameraService provides an stopCamera function to stop the camera.
			 */
this.stopCamera=function(){if(this.cameraIsOn){
// https://github.com/jhuckaby/webcamjs/blob/master/webcam.js
if(this.stream.getVideoTracks){
// get video track to call stop on it
var tracks=this.stream.getVideoTracks();tracks&&tracks[0]&&tracks[0].stop&&tracks[0].stop()}else this.stream.stop&&
// deprecated, may be removed in future
this.stream.stop();
//end webcamjs
this.cameraIsOn=!1}}}]),angular.module("WebCoreModule").service("WcDataFileService",["$q","$window",function($q,$window){this.getFileType=function(fileDef){var fileType=fileDef.type.replace(/[a-z]+\//,"");return fileType},/**
		 * @ngdoc method
		 * @name WcImageFileService.prepareForFileUpload
		 * @methodOf WebCoreModule.service:WcDataFileService
		 * @param {String} base64DataUri This string value holds the data uri
		 * @returns {Object} The object value holds the file
		 * @description
		 * The WcImageFileService provides a prepareForFileUpload function to create a file  object from the provided url.
		 */
this.prepareForFileUpload=function(base64DataUri){var fileObj={MIMEType:base64DataUri.match(/^[^,]*,/,"")[0],base64String:base64DataUri.replace(/^[^,]*,/,"")};return fileObj},/**
		 * @ngdoc method
		 * @name WcImageFileService.readFile
		 * @methodOf WebCoreModule.service:WcDataFileService
		 * @param {Object} fileDef This object value holds definition of the file.
		 * @returns {Promise} Return dataURI as a promise
		 * @description
		 * The WcImageFileService provides a readFile function to read the uploaded file.
		 */
this.readFile=function(fileDef){
// Return dataURI as a promise
//https://gist.github.com/jollytoad/4201905
var deferred=$q.defer(),reader=new $window.FileReader;return reader.onload=function(loadEvent){var dataUri=loadEvent.target.result;deferred.resolve(dataUri)},reader.onerror=function(){deferred.reject(fileDef)},reader.readAsDataURL(fileDef),deferred.promise}}]),angular.module("WebCoreModule").service("WcHttpRequestService",["$rootScope","$q","$http","$window","$timeout","$interpolate","WcAlertConsoleService",function($rootScope,$q,$http,$window,$timeout,$interpolate,WcAlertConsoleService){this.configuration={xsrfCookieName:"WSL-credential",withCredentials:!0,headers:{},timeout:1e4,baseUrl:"",cache:!1,pingTrustPeriodMS:1e3,unAuthenticatedCallback:function(){},unprotectedPingRoute:"unprotected/ping",queuedRequestMessages:{}},/**
			 * @ngdoc method
			 * @name WcHttpRequestService.configureDefaults
			 * @methodOf WebCoreModule.service:WcHttpRequestService
			 * @param {Object} config Options object to configure default values used by the WcHttpRequestService. Config properties that can be set in this object include:
			 *  - baseUrl: String value identifying the base url to build requests from (e.g., wwwdev.jab.ford.com/Jab7Web/api). Defaults to ''
			 *  - xsrfCookieName: String value used to identify a cookie that should always be sent. Defaults to 'WSL-credential'.
			 *  - withCredentials: Boolean value for whether or not credentials should be sent on requests. Defaults to true.
			 *  - headers: Object containing headers to send on each request. Defaults to {}.
			 *  - timeout: Integer to identify how long to wait, in MS, before timing out a connection attempt. Defaults to 10000ms.
			 *  - cache: Boolean to determine app-wide caching. Defaults to false, and typically should not be changed.
			 *  - pingTrustPeriodMS: Integer to identify a trust period when calling an endpoint to check connectivity. Defaults to 1000ms, and typically doesn't need to be changed.
			 *  - unAuthenticatedCallback: Function to be called when the service determines it has lost authentication.
			 *  - unprotectedPingRoute: String value identifying the route to use for the unprotected ping request
			 * @description
			 * The WcHttpRequestService configures itself with application-wide defaults when it starts up. The configureDefaults function allows
			 * you to override those defaults at the app level, so that the new parameters will apply to any request made via the service.
			 */
this.configureDefaults=function(config){angular.extend(this.configuration,config)},this.requestConfigurationMapper=function(config){var httpConfig=angular.copy(this.configuration);return delete httpConfig.baseUrl,delete httpConfig.pingTrustPeriodMS,delete httpConfig.unAuthenticatedCallback,delete httpConfig.unprotectedPingRoute,delete httpConfig.queuedRequestMessages,angular.extend(httpConfig,config),delete httpConfig.cache,httpConfig},this.urlBuilder=function(url){
// if we detect that the url contains a protocol from the endpoint, it's already a full url
// if we detect that the url contains a protocol from the endpoint, it's already a full url
return url.indexOf("http://")>-1||url.indexOf("https://")>-1?url:this.configuration.baseUrl+url},this.get=function(url,config){var interceptedParams=this.triggerRequestInterceptors(url,null,config);url=interceptedParams.url,config=interceptedParams.config;
//if params are passed in, they go on the url only after hitting $http. we need them sooner for cache storage purposes
var parseParams=function(params){var retString="/";return Object.keys(params).forEach(function(key){retString="/"==retString?retString+key+":"+params[key]:retString+"-"+key+":"+params[key]}),retString},urlForCache=url;
// if cache is enabled, should we attempt to use cached data or refresh from the server?
// set alwaysRefresh to never use cache unless offline
// set forceRefresh to true to override default behavior and request from the server on demand
if(config&&config.params&&(urlForCache=url+parseParams(config.params)),config&&config.cache&&!config.alwaysRefresh&&!config.forceRefresh){var cachedData;if("localStorage"==config.cache?cachedData={data:this.getFromLocalStorage(urlForCache)}:"sessionStorage"==config.cache&&(cachedData=this.getFromSessionStorage(urlForCache)),cachedData&&cachedData.data)return $q.when(cachedData)}return $http.get(this.urlBuilder(url),this.requestConfigurationMapper(config)).then(angular.bind(this,function(response){
//SHANIKIA
return $rootScope.$broadcast("Online"),response=this.triggerResponseInterceptors(response),config&&("localStorage"==config.cache?this.storeInLocalStorage(urlForCache,response.data):"sessionStorage"==config.cache&&this.storeInSessionStorage(urlForCache,response.data)),{data:response.data,status:response.status}}),angular.bind(this,function(error){
//we got to the server, but it errored out. since we know the server is available, return the error object and let the app decide what to do.
//we got to the server, but it errored out. since we know the server is available, return the error object and let the app decide what to do.
return this.triggerErrorInterceptors(error),error.status>0?$q.reject(error):this.getNetworkState().then(angular.bind(this,function(state){if("offline"==state&&config){var cachedData;return"localStorage"==config.cache?cachedData={data:this.getFromLocalStorage(urlForCache)}:"sessionStorage"==config.cache&&(cachedData=this.getFromSessionStorage(urlForCache)),cachedData&&cachedData.data?$q.when(cachedData)["finally"](function(){
// we are not rejecting the promise but are still operating 'offline'
$timeout(function(){$rootScope.$broadcast("Offline")})}):$q.reject("Offline: No cached data available!")}return $q.reject(error)}))}))},this.post=function(url,data,config){var interceptedParams=this.triggerRequestInterceptors(url,data,config);return url=interceptedParams.url,data=interceptedParams.data,config=interceptedParams.config,$http.post(this.urlBuilder(url),data,this.requestConfigurationMapper(config)).then(angular.bind(this,function(response){return $rootScope.$broadcast("Online"),response=this.triggerResponseInterceptors(response),{data:response.data,status:response.status}}),angular.bind(this,function(error){return this.triggerErrorInterceptors(error),error.status<=0&&config&&"queue"==config.offline&&!config.fromQueue?(this.queueRequest("post",url,data,config),error.status="queue",$q.when(error)):$q.reject(error)}))},this.put=function(url,data,config){var interceptedParams=this.triggerRequestInterceptors(url,data,config);return url=interceptedParams.url,data=interceptedParams.data,config=interceptedParams.config,$http.put(this.urlBuilder(url),data,this.requestConfigurationMapper(config)).then(angular.bind(this,function(response){return $rootScope.$broadcast("Online"),response=this.triggerResponseInterceptors(response),{data:response.data,status:response.status}}),angular.bind(this,function(error){return this.triggerErrorInterceptors(error),error.status<=0&&config&&"queue"==config.offline&&!config.fromQueue?(this.queueRequest("put",url,data,config),error.status="queue",$q.when(error)):$q.reject(error)}))},this["delete"]=function(url,config){var interceptedParams=this.triggerRequestInterceptors(url,null,config);return url=interceptedParams.url,config=interceptedParams.config,$http["delete"](this.urlBuilder(url),this.requestConfigurationMapper(config)).then(angular.bind(this,function(response){return $rootScope.$broadcast("Online"),response=this.triggerResponseInterceptors(response),{data:response.data,status:response.status}}),angular.bind(this,function(error){return this.triggerErrorInterceptors(error),error.status<=0&&config&&"queue"==config.offline&&!config.fromQueue?(this.queueRequest("delete",url,void 0,config),error.status="queue",$q.when(error)):$q.reject(error)}))},this.getFromLocalStorage=function(key){var cachedData=$window.localStorage.getItem(key);try{cachedData=angular.fromJson(cachedData)}finally{return cachedData}},this.getFromSessionStorage=function(key){var cachedData=$window.sessionStorage.getItem(key);try{cachedData=angular.fromJson(cachedData)}finally{return cachedData?{data:cachedData}:cachedData}},this.storeInLocalStorage=function(key,value){angular.isString(value)||(value=angular.toJson(value)),$window.localStorage.setItem(key,value)},this.storeInSessionStorage=function(key,value){angular.isString(value)||(value=angular.toJson(value)),$window.sessionStorage.setItem(key,value)},this.removeFromLocalStorage=function(key){$window.localStorage.removeItem(key)},this.removeFromSessionStorage=function(key){$window.sessionStorage.removeItem(key)},this.addMessageForQueuedRequest=function(verb,url,data,config,response){
//set up default messages
var message,type;
//ensure a message object has been passed in
if(200==response.status?(message="Queued request submitted successfully: "+verb+" to endpoint "+url+", status: "+response.status,type="success"):409==response.status?(message="Queued request failed to be submitted due to a conflict: "+verb+" to endpoint "+url+", status: "+response.status,type="danger"):500==response.status&&(message="Queued request failed to be submitted due to a server error: "+verb+" to endpoint "+url+", status: "+response.status,type="danger"),this.configuration.queuedRequestMessages&&0!=Object.keys(this.configuration.queuedRequestMessages).length)
//if we can't match our url identically, we likely are dealing with a put or delete with an id on the url
if(this.configuration.queuedRequestMessages[verb][url]){if(this.configuration.queuedRequestMessages[verb][url][response.status]){message=this.configuration.queuedRequestMessages[verb][url][response.status];var messageExp=$interpolate(message);message=messageExp({verb:verb,url:url,data:data,config:config,response:response})}}else if(this.configuration.queuedRequestMessages[verb][url.substring(0,url.lastIndexOf("/"))][response.status]){message=this.configuration.queuedRequestMessages[verb][url.substring(0,url.lastIndexOf("/"))][response.status];var messageExp=$interpolate(message);message=messageExp({verb:verb,url:url,data:data,config:config,response:response})}
//add the message
WcAlertConsoleService.addMessage({message:message,type:type,multiple:!1,errorOnStateChange:!1,timeout:20})},this.processOfflineQueue=function(deregisterListener){
//retrieve the current queue then clear it and the associated listener so it won't be triggered again.
//remember that each attempted request could add itself back to the queue if it fails
var currentQueue=this.getFromLocalStorage("offlineQueue");this.removeFromLocalStorage("offlineQueue"),deregisterListener();for(var item=currentQueue.shift();item;){item.config.fromQueue=!0;var requestPromise;requestPromise="delete"==item.verb?this["delete"](item.url,item.config):this[item.verb](item.url,item.data,item.config);
//handler for both the success and error cases
var handler=angular.bind(this,function(item,response){this.addMessageForQueuedRequest(item.verb,item.url,item.data,item.config,response)},item);
//chain to add messages, as the verb functions themselves don't add them
requestPromise.then(handler,handler),item=currentQueue.shift()}},this.setupQueueTrigger=function(){var deregisterListener=$rootScope.$on("Online",angular.bind(this,function(){this.processOfflineQueue(deregisterListener)}))},this.queueRequest=function(verb,url,data,config){var currentQueue=this.getFromLocalStorage("offlineQueue");currentQueue?(currentQueue.push({verb:verb,url:url,data:data,config:config}),this.storeInLocalStorage("offlineQueue",currentQueue)):(this.storeInLocalStorage("offlineQueue",[{verb:verb,url:url,data:data,config:config}]),this.setupQueueTrigger())},
//need to do this when the service is created to establish the queue processing trigger
this.getFromLocalStorage("offlineQueue")&&this.setupQueueTrigger(),this.requestInterceptors=[],this.responseInterceptors=[],this.errorInterceptors=[],/**
			 * @ngdoc method
			 * @name WcHttpRequestService.addRequestIntercetor
			 * @methodOf WebCoreModule.service:WcHttpRequestService
			 * @param {Function} interceptor A function to trigger before requests are sent.
			 * @description
			 * The WcHttpRequestService allows you to include callback interceptor functions before a request is sent. These
			 * custom functions can adjust the request before it is sent to the server. Once attached, the service will always
			 * trigger all request interceptors before triggering the request itself.
			 */
this.addRequestInterceptor=function(interceptor){this.requestInterceptors.push(interceptor)},this.triggerRequestInterceptors=function(url,data,config){for(var index=0;index<this.requestInterceptors.length;){var newParms=this.requestInterceptors[index](url,data,config);newParms&&(newParms.url&&(url=newParms.url),newParms.data&&(data=newParms.data),newParms.config&&(config=newParms.config)),index++}return{url:url,data:data,config:config}},/**
			 * @ngdoc method
			 * @name WcHttpRequestService.addResponseIntercetor
			 * @methodOf WebCoreModule.service:WcHttpRequestService
			 * @param {Function} interceptor A function to trigger before responses are processed and returned.
			 * @description
			 * The WcHttpRequestService allows you to include callback interceptor functions after a service response is received
			 * and before the returned data is given to the application code. These custom functions can adjust the response data or
			 * trigger behaviors before the data is given to the application. Once attached, the service will always trigger all response
			 * interceptors before returning the data and the control flow back to the application.
			 */
this.addResponseInterceptor=function(interceptor){this.responseInterceptors.push(interceptor)},this.triggerResponseInterceptors=function(response){for(var index=0;index<this.responseInterceptors.length;){var newResponse=this.responseInterceptors[index](response);newResponse&&(response=newResponse),index++}return response},/**
			 * @ngdoc method
			 * @name WcHttpRequestService.addErrorIntercetor
			 * @methodOf WebCoreModule.service:WcHttpRequestService
			 * @param {Function} interceptor A function to trigger before error responses are processed and returned.
			 * @description
			 * The WcHttpRequestService allows you to include callback interceptor functions after an erroneous service response is received
			 * and before the error is given to the application code. These custom functions can adjust for the error or
			 * trigger behaviors before control is given back to the application. Once attached, the service will always trigger all error
			 * interceptors before returning the errors and the control flow back to the application.
			 */
this.addErrorInterceptor=function(interceptor){this.errorInterceptors.push(interceptor)},/**
			 These 'Interceptors' currently function more as a callback/event handler
			 Keeping name as interceptor to align with Restangular and other function names
			 There is potential for refactoring to support graceful error recovery
			 **/
this.triggerErrorInterceptors=function(error){for(var index=0;index<this.errorInterceptors.length;)this.errorInterceptors[index](error),index++},/**
			 *
			 *    Network Detection
			 *
			 * **/
this._lastPingRequestTimestamp=0,this._trustedResponse="",this._pendingRequests=0,this._currentPingRequestPromise={},this._networkStatusResponses=["online","unauthenticated","offline"],/**
			 * @ngdoc method
			 * @name WcHttpRequestService.getNetworkState
			 * @methodOf WebCoreModule.service:WcHttpRequestService
			 * @description
			 * @returns {Promise} Promise wrapped value to identify the current state of the application's connectivity to its server.
			 * The WcHttpRequestService allows you to interrogate the status of the the application's connectivity to its application
			 * server. This status check is used behind the scenes across various webCore services to determine proper actions
			 * when connectivity is lost. This function can also be triggered by application code, if the need arises.
			 *
			 * For this function to work properly, the application's services need to expose an endpoint unprotected by authentication
			 * controls. This service will use that endpoint to determine whether the application is online, unauthenicated, or offline.
			 */
/* can return statuses defined in _networkStatusResponses
			 *
			 * will always resolve promise, never reject - error case is a valid response
			 * */
this.getNetworkState=function(){if(this._pendingRequests>0)
// already pinging server, do not re-request and return saved promise
return this._currentPingRequestPromise;var currentTime=new Date;
//needs to use $http itself here to ensure we don't cause issues with the network detection loop.
return currentTime-this._lastPingRequestTimestamp>this.configuration.pingTrustPeriodMS?(this._pendingRequests++,this._lastPingRequestTimestamp=currentTime,this._trustedResponse="",this._currentPingRequestPromise=$http.get(this.urlBuilder(this.configuration.unprotectedPingRoute),this.requestConfigurationMapper(this.configuration)).then(angular.bind(this,function(){
// we only query the network when there is an error in retrieving data from the server
// if we can access the unprotected ping endpoint, we know the issue is most likely that the user is not logged in
//unauthenticated
// perform callback
return this._pendingRequests--,this._currentPingRequestPromise={},this._trustedResponse=this._networkStatusResponses[1],this.configuration.unAuthenticatedCallback(),$rootScope.$broadcast("Unauthenticated"),$q.when(this._networkStatusResponses[1])}),angular.bind(this,function(){
// if we cannot access the unprotected ping endpoint, we must be offline
// offline
return this._pendingRequests--,this._currentPingRequestPromise={},this._trustedResponse=this._networkStatusResponses[2],$rootScope.$broadcast("Offline"),$q.when(this._networkStatusResponses[2])})),this._currentPingRequestPromise):$q.when(this._trustedResponse)}}]),angular.module("WebCoreModule").service("WcImageFileService",["$q","$window",function($q,$window){
// I don't want to make this a public method, but we run into problems testing image.onload.
// If someone finds a way to mock the Image.onload event, do that and make this method private.
this.loadImage=angular.bind(this,function(imageSrc,width,height){var deferred=$q.defer(),canvas=this.generateCanvas();canvas.width=width,canvas.height=height;var context=canvas.getContext("2d"),image=new Image;return image.onload=function(){context.drawImage(image,0,0,canvas.width,canvas.height),deferred.resolve(canvas)},image.src=imageSrc,deferred.promise}),/**
		 * @ngdoc method
		 * @name WcImageFileService.createImageURI
		 * @methodOf WebCoreModule.service:WcImageFileService
		 * @param {String} imageURI This string value holds the image name
		 * @param {Intiger} width(optional) This integer value holds the width of the image. The default value of this field is 200px
		 * @param {Intiger} height(optional) This integer value holds the height of the image. The default value of this field is 200px
		 * @returns {String} The string value is the image uri
		 * @description
		 * The WcImageFileService provides a createImageURI function to create the image uri based on image name, width and height.
		 */
this.createImageURI=function(imageURI,width,height){return width=width||200,height=height||200,this.loadImage(imageURI,width,height).then(function(canvas){return $q.when(canvas.toDataURL("image/jpeg",1))})},
// Only for testing. We have yet to find out how to mock document.createElement without
// blowing up angular-mock. We have a Stack Overflow question out there to hopefully
// find an answer.
// http://stackoverflow.com/questions/35369629/using-jasmine-to-spy-on-document-createelement-throws-error-from-angular-mock
this.generateCanvas=function(){return document.createElement("canvas")}}]),angular.module("WebCoreModule").provider("WcTranslateConfiguratorService",["$translateProvider",function($translateProvider){
//expose the translate provider in case users need to call through to it
this.translateProvider=$translateProvider,this.configuration={sanitizationStrategy:"escape",loader:"$translatePartialLoader",loaderObj:{urlTemplate:"translations/{lang}/{part}.json"},langKeyArray:["en","zh","ru"],langKeyObj:{"en_*":"en","en-*":"en",zh_CN:"zh",zh_HK:"zh",ru_RU:"ru"},fallbackLang:"en"},/**
	 * @ngdoc method
	 * @name WcTranslateConfiguratorServiceProvider.configureTranslateService
	 * @methodOf WebCoreModule.service:WcTranslateConfiguratorServiceProvider
	 * @param {Object} config Options object to configure default values used by the WcTranslateConfiguratorServiceProvider. Config properties that can be set in this object include:
	 *  - loader: String to identify the loader service to use. Defaults to '$translatePartialLoader' and likely does not need to be changed.
	 *  - loaderObj: Object defining loader configuration. Defaults to '{urlTemplate: 'translations/{lang}/{part}.json'}', defining the default location of translation json files.
	 *  - langKeyArray: Array of strings defining the languages the app should support. Defaults to ['en', 'zh', 'ru'].
	 *  - langKeyObj: Object defining mappings between two and four character language codes. Should define mappings for any languages in use.
	 *  - fallbackLang: String identifying the language to use if a non-supported language is requested. Defaults to 'en'
	 * @description
	 * The WcTranslateConfiguratorServiceProvider configures itself with application-wide defaults when it starts up. The configureDefaults function allows
	 * you to override those defaults at the app level, so that the new parameters will apply to the configuration of the translation modules.
	 */
this.configureTranslateService=function(config){
//default config is set - if different config is passed in, use it instead
config&&angular.extend(this.configuration,config),$translateProvider.useSanitizeValueStrategy(this.configuration.sanitizationStrategy),$translateProvider.useLoader(this.configuration.loader,this.configuration.loaderObj),$translateProvider.registerAvailableLanguageKeys(this.configuration.langKeyArray,this.configuration.langKeyObj),$translateProvider.determinePreferredLanguage(),$translateProvider.fallbackLanguage(this.configuration.fallbackLang),$translateProvider.use($translateProvider.preferredLanguage())},
//this is essentially a factory function
this.$get=["$translate","$translatePartialLoader",function($translate,$translatePartialLoader){
//return our object when all is said and done
/**
	 * @ngdoc method
	 * @name WcTranslateConfiguratorService.loadPartAndRefresh
	 * @methodOf WebCoreModule.service:WcTranslateConfiguratorService
	 * @param {String} partString String defining the language partial file to load. For instance, to load the JabUiApp.json file, pass in 'JabUiApp'
	 * @description
	 * The WcTranslateConfiguratorService exposes a helper function to add a language partial json file to the language database
	 * and refresh the application using it.
	 */
return this.loadPartAndRefresh=function(partString){$translatePartialLoader.addPart(partString),$translate.refresh()},this}]}]),angular.module("WebCoreModule").service("WcWebtrendsService",["$rootScope","$window","$state","$timeout",function($rootScope,$window,$state,$timeout){this._enabled=!1,/**
		 * @ngdoc method
		 * @name WcWebtrendsService.enable
		 * @methodOf WebCoreModule.service:WcWebtrendsService
		 * @description
		 * Calling the enable function enables WebTrends tracking for the application.
		 */
this.enable=function(){this._enabled=!0},this.trackData=function(){var uri,urlPart;return""!==$window.location.hash&&(urlPart=$window.location.hash+$window.location.search),uri=urlPart&&urlPart.replace("#/","")!==$state.$current.name?urlPart+":"+$state.$current.name:urlPart,uri||(uri=":"+$state.$current.name),$window.dcsMultiTrack("DCS.dcsuri",uri),uri},$rootScope.$on("$stateChangeSuccess",angular.bind(this,function(){this._enabled&&$window.dcsMultiTrack&&
// $timeout required to allow Angular to update browser URL
$timeout(angular.bind(this,function(){$rootScope.$apply(),this.trackData()}))}))}]),angular.module("WebCoreModule").factory("WcDateRangePickerPrototype",["$rootScope",function($rootScope){function WcDateRangePickerPrototype(config){var startDate,endDate,minDate,maxDate,startDateFieldName,endDateFieldName,form;config&&(startDate=config.startDate?config.startDate:null,endDate=config.endDate?config.endDate:null,minDate=config.minDate?config.minDate:null,maxDate=config.maxDate?config.maxDate:null,startDateFieldName=config.startDateFieldName?config.startDateFieldName:null,endDateFieldName=config.endDateFieldName?config.endDateFieldName:null,form=config.form?config.form:null),this.isStartDateOpen=!1,this.isEndDateOpen=!1,this.load(startDate,endDate,minDate,maxDate),$rootScope.$watch(angular.bind(this,function(){return this.startDate}),angular.bind(this,function(newValue){this.minEndDate=newValue?newValue:this.minDate})),$rootScope.$watch(angular.bind(this,function(){return this.endDate}),angular.bind(this,function(newValue){this.maxStartDate=newValue?newValue:this.maxDate})),form&&startDateFieldName&&endDateFieldName?$rootScope.$watch(function(){var dateDisabledArray=form.$error["date-disabled"];return dateDisabledArray?dateDisabledArray.length:0},angular.bind(this,function(newVal){var dateDisabledArray=form.$error["date-disabled"];if(newVal>0)for(var i=0;i<dateDisabledArray.length;i++)
//this only operates on two date pickers now, so no need to look further in the createBookingForm.
//we'd need to augment this if we were using more datepickers
dateDisabledArray[i].$viewValue==form[startDateFieldName].$viewValue?form[startDateFieldName].$setValidity("dateRange",!dateDisabledArray[i].$error["date-disabled"]):form[endDateFieldName].$setValidity("dateRange",!dateDisabledArray[i].$error["date-disabled"]);else form[startDateFieldName].$setValidity("dateRange",!0),form[endDateFieldName].$setValidity("dateRange",!0)})):console.log("The DateRangePicker cannot support validation indicators without having been provided the formObj and the field names.")}/**
		 * @ngdoc property
		 * @name WcDateRangePickerPrototype.startDate
		 * @propertyOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @returns {Date} The Date object created to match the date selected by the user in the start date field.
		 * @description
		 * The startDate property is used as the model variable bound to the start date input field.
		 */
/**
		 * @ngdoc property
		 * @name WcDateRangePickerPrototype.endDate
		 * @propertyOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @returns {Date} The Date object created to match the date selected by the user in the end date field.
		 * @description
		 * The endDate property is used as the model variable bound to the end date input field.
		 */
/**
		 * @ngdoc property
		 * @name WcDateRangePickerPrototype.minDate
		 * @propertyOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @returns {Date} The Date object used to identify the minimum valid date for the date range.
		 * @description
		 * The minDate property defines the minimum date that should be selectable as the start date for the range.
		 */
/**
		 * @ngdoc property
		 * @name WcDateRangePickerPrototype.maxDate
		 * @propertyOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @returns {Date} The Date object used to identify the maximum valid date for the date range.
		 * @description
		 * The maxDate property defines the maximum date that should be selectable as the end date for the range.
		 */
/**
		 * @ngdoc property
		 * @name WcDateRangePickerPrototype.minStartDate
		 * @propertyOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @returns {Date} The Date object used to identify the minimum valid date for the start date field.
		 * @description
		 * The minStartDate property defines the minimum date that should be selectable in the start date field.
		 */
/**
		 * @ngdoc property
		 * @name WcDateRangePickerPrototype.maxStartDate
		 * @propertyOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @returns {Date} The Date object used to identify the maximum valid date for the start date field.
		 * @description
		 * The maxStartDate property defines the maximum date that should be selectable in the start date field.
		 */
/**
		 * @ngdoc property
		 * @name WcDateRangePickerPrototype.minEndDate
		 * @propertyOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @returns {Date} The Date object used to identify the minimum valid date for the end date field.
		 * @description
		 * The minEndDate property defines the minimum date that should be selectable in the end date field.
		 */
/**
		 * @ngdoc property
		 * @name WcDateRangePickerPrototype.maxEndDate
		 * @propertyOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @returns {Date} The Date object used to identify the maximum valid date for the end date field.
		 * @description
		 * The maxEndDate property defines the maximum date that should be selectable in the end date field.
		 */
/**
		 * @ngdoc method
		 * @name WcDateRangePickerPrototype.openStartDate
		 * @methodOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @param {Event} $event Event object describing what happened when the function was called.
		 * @description
		 * The WcDateRangePickerPrototype provides an openStartDate function to appropriately trigger the date picker control
		 * to open and to keep track of open status of the control.
		 */
/**
		 * @ngdoc method
		 * @name WcDateRangePickerPrototype.openEndDate
		 * @methodOf WebCoreModule.service:WcDateRangePickerPrototype
		 * @param {Event} $event Event object describing what happened when the function was called.
		 * @description
		 * The WcDateRangePickerPrototype provides an openEndDate function to appropriately trigger the date picker control
		 * to open and to keep track of open status of the control.
		 */
return WcDateRangePickerPrototype.prototype.load=function(startDate,endDate,minDate,maxDate){this.startDate=startDate||null,//The day the start datepicker defaults to
this.endDate=endDate||null,//The day the end datepicker defaults to
this.minDate=minDate||null,//The minimum day the start datepicker can have
this.maxDate=maxDate||null,//The maximum day the end datepicker can have
this.minStartDate=this.minDate,this.maxStartDate=this.endDate?this.endDate:this.maxDate,//TODO: verify endDate <= maxDate
this.minEndDate=this.startDate?this.startDate:this.minDate,//TODO: verify startDate >= minDate
this.maxEndDate=this.maxDate},WcDateRangePickerPrototype.prototype.openStartDate=function($event){$event.preventDefault(),$event.stopPropagation(),this.isStartDateOpen===!0?this.isStartDateOpen=!1:(this.isStartDateOpen=!0,this.isEndDateOpen=!1)},WcDateRangePickerPrototype.prototype.openEndDate=function($event){$event.preventDefault(),$event.stopPropagation(),this.isEndDateOpen===!0?this.isEndDateOpen=!1:(this.isEndDateOpen=!0,this.isStartDateOpen=!1)},WcDateRangePickerPrototype}]),angular.module("WebCoreModule").factory("WcHttpEndpointPrototype",["WcHttpRequestService",function(WcHttpRequestService){/**
		 * @ngdoc property
		 * @name WcHttpEndpointPrototype.route
		 * @propertyOf WebCoreModule.service:WcHttpEndpointPrototype
		 * @returns {String} String defining the endpoint route to append to the baseURL for this endpoint.
		 * @description
		 * Passing in the required route string for an endpoint will establish the URL this endpoint should operate on
		 * by appending the route to the end of the baseURL.
		 */
/**
		 * @ngdoc property
		 * @name WcHttpEndpointPrototype.baseURL
		 * @propertyOf WebCoreModule.service:WcHttpEndpointPrototype
		 * @returns {String} String defining a baseURL to override the application wide baseURL for this endpoint.
		 * @description
		 * Passing in an optional baseURL allows the user to override the baseURL for this endpoint with the passed in baseURL.
		 */
function Endpoint(route,baseURL){this.baseUrl=baseURL,this.route=route,baseURL&&(this.route=this.baseUrl+this.route)}return Endpoint.prototype={subRoute:function(id){return new Endpoint(this.route+"/"+id)},/**
			 * @ngdoc method
			 * @name WcHttpEndpointPrototype.get
			 * @methodOf WebCoreModule.service:WcHttpEndpointPrototype
			 * @param {Object} options Options object to configure what happens when this verb is called. Config properties that can be set in this object include:
			 *  - cache: set to 'localStorage' or 'sessionStorage' to enable caching for this call
			 *  - alwaysRefresh: set to true to have the request always directed to the server when operating online. Each time the results are cached, making them available for offline usage. set to false to have only the first request directed to the server when operating online. Every subsequent request, online or offline, will be retrieved from the cache.
			 * @returns {Promise} The data retreived from the backing service wrapped in a promise.
			 * @description
			 * The WcHttpEndpointPrototype provides a get function to trigger an HTTP GET against the established endpoint URL.
			 *
			 * A get call can be configured to cache the returned results from the server call. These results can be stored in
			 * localStorage or session storage. Caching behavior can also be configured to happen in one of two ways:
			 *  - An always refreshing cache will always go to the server when operating online, storing a copy of the data retrieved in the specified cache.
			 *  - A non refreshing cache will go to the server with the first request when operating online, caching the results, but all subsequent requests will be retrieved from the cache, not from the server.
			 */
get:function(options){return WcHttpRequestService.get(this.route,options)},/**
			 * @ngdoc method
			 * @name WcHttpEndpointPrototype.post
			 * @methodOf WebCoreModule.service:WcHttpEndpointPrototype
			 * @param {Object} data Data to send to the endpoint when this verb is called.
			 * @param {Object} options Options object to configure what happens when this verb is called.
			 * @returns {Promise} The data retreived from the backing service wrapped in a promise.
			 * @description
			 * The WcHttpEndpointPrototype provides a post function to trigger an HTTP POST against the established endpoint URL.
			 */
post:function(data,options){return WcHttpRequestService.post(this.route,data,options)},/**
			 * @ngdoc method
			 * @name WcHttpEndpointPrototype.put
			 * @methodOf WebCoreModule.service:WcHttpEndpointPrototype
			 * @param {String} id Identifier for which record we should operate on when this verb is called.
			 * @param {Object} data Data to send to the endpoint when this verb is called.
			 * @param {Object} options Options object to configure what happens when this verb is called.
			 * @returns {Promise} The data retreived from the backing service wrapped in a promise.
			 * @description
			 * The WcHttpEndpointPrototype provides a put function to trigger an HTTP PUT against the established endpoint URL.
			 */
put:function(id,data,options){return WcHttpRequestService.put(this.route+"/"+id,data,options)},/**
			 * @ngdoc method
			 * @name WcHttpEndpointPrototype.delete
			 * @methodOf WebCoreModule.service:WcHttpEndpointPrototype
			 * @param {String} id Identifier for which record we should operate on when this verb is called.
			 * @param {Object} options Options object to configure what happens when this verb is called.
			 * @returns {Promise} The data retreived from the backing service wrapped in a promise.
			 * @description
			 * The WcHttpEndpointPrototype provides a delete function to trigger an HTTP DELETE against the established endpoint URL.
			 */
"delete":function(id,options){return WcHttpRequestService["delete"](this.route+"/"+id,options)}},Endpoint}]),angular.module("WebCoreModule").directive("required",function(){return{restrict:"A",controller:["WcTranslateConfiguratorService","$compile","$timeout",function(WcTranslateConfiguratorService,$compile,$timeout){this.WcTranslateConfiguratorService=WcTranslateConfiguratorService,this.compile=$compile,this.timeout=$timeout}],link:function(scope,elem,attrs,ctrl){ctrl.WcTranslateConfiguratorService.loadPartAndRefresh("WC-required"),ctrl.timeout(function(){
// add aria required attribute
//$(elem).attr('aria-required', true);
// insert required abbreviation inside of label
var insertionPoint=$('label[for="'+attrs.id+'"]');
// if it's a radio or checkbox, try to find legend for fieldset instead
"checkbox"!=elem[0].type&&"radio"!=elem[0].type||(insertionPoint=elem.closest("fieldset").find("legend")),
// check to make sure abbr is not already there before adding
0!=insertionPoint.has('abbr[title="Required"]').length||attrs.disabled||attrs.readonly||insertionPoint.prepend('<abbr class="required h6" title="Required">*</abbr>');var formElem=insertionPoint.closest("form");
//lastly, check for the form legend and add it if necessary
0!=formElem.has("div.required-legend").length||attrs.disabled||attrs.readonly||
//this solution limits FOUC, but the event means the item is added multiple times. not good.
//ctrl.rootScope.$on('$translateChangeSuccess', function() {
//	formElem.prepend('<div class="required-legend"><span class="required-text"><abbr class="required h6" title="Required">*</abbr> ' + ctrl.translate.instant("required.requiredText") + '</span></div>');
//});
//although this exposes a short FOUC, it's a better solution as the legend is only added once.
//wrap in ctrl.timeout to help limit race conditions
//ctrl.timeout(function(){
formElem.prepend(ctrl.compile('<div class="required-legend hidden-xs"><span class="required-text"><abbr class="required h6" title="Required">*</abbr> {{"required.requiredText" | translate}}</span></div>')(scope))},100)}}}),angular.module("WebCoreModule").directive("wcAlertConsole",function(){return{restrict:"A",template:'<div id="alert-console"><div class="alert alert-dismissable"ng-swipe-right="closeAlert(alert.uniqueishID)" role="alert" ng-repeat="alert in visibleMessages" type="{{alert.type}}" ng-class="{\'zoom-out-animate\': alert.fadeOut, \'fade-out\': alert.fadeOut, \'alert-success\' : alert.type == \'success\', \'alert-danger\' : alert.type == \'danger\', \'alert-warning\' : alert.type == \'warning\'}"> <span class="glyphicon" ng-class="{\'glyphicon-ok\': alert.type == \'success\', \'glyphicon-warning-sign\': alert.type == \'warning\', \'glyphicon-remove-circle\': alert.type == \'danger\'}"></span><button class="close" ng-click="closeAlert(alert.uniqueishID)"><span aria-hidden="true">&#120;</span><span class="sr-only">Close</span></button><div><span ng-bind-html="alert.message"></span><!--<progressbar ng-if="!alert.persist" class="progress-striped active" value="100 - alert.timeout*10" type="{{alert.type}}"></progressbar>--></div></div></div>',replace:!1,controller:["$scope","WcAlertConsoleService","$timeout",function($scope,WcAlertConsoleService,$timeout){$scope.visibleMessages=[],$scope.closeAlert=function(uniqueishID){
// manually trigger fade out
WcAlertConsoleService.removeMessage(uniqueishID,!0)},WcAlertConsoleService.getSettings().removeErrorOnStateChange&&$scope.$on("$stateChangeStart",function(){WcAlertConsoleService.removeErrorMessages()}),
// watch on alert messages
$scope.$watch(function(){var messages=WcAlertConsoleService.getMessages(!0);return messages},function(newMsgs,oldMsgs){$scope.visibleMessages=newMsgs,
// move user to focus on alert if new message is added
$timeout(function(){if(newMsgs.length>oldMsgs.length){var userYpos=$(document).scrollTop(),msgYpos=$("div.alert").last().offset();msgYpos=msgYpos.top-15,userYpos>msgYpos&&$("html, body").animate({scrollTop:msgYpos},100)}},0)},!0)}]}}),angular.module("WebCoreModule").directive("wcChart",function(){return{restrict:"E",scope:{data:"&data",format:"@format",events:"&events",draw:"&draw",options:"&options",responsiveOptions:"&responsiveOptions"},controller:["$scope","$window","$timeout",function($scope,$window,$timeout){if(!$window.Chartist)throw"Missing required dependency - Chartist.js";this.data=$scope.data(),this.format=$scope.format,this.events=$scope.events()||[],this.options=$scope.options()||null,this.responsiveOptions=$scope.responsiveOptions()||null,this.bindEvents=function(chart){this.events.forEach(function(curVal){var eventHandler=function(){curVal.handler(),$timeout(function(){$scope.$apply()})};chart.bind(curVal.name,eventHandler)})},this.render=function($element){return Chartist[this.format]($element,this.data,this.options,this.responsiveOptions)}}],link:function($scope,$element,$attrs,ctrl){
// jshint unused:true
// Create Chart
var element=$element[0],chart=ctrl.render(element);ctrl.bindEvents($element);
// Add Draw Event Separately
var drawFunc=$scope.draw();drawFunc&&chart.on("draw",drawFunc),
// Watch for Changes to Data Set
$scope.$watch(function(){return $scope.data()},function(newData,oldData){newData!==oldData&&chart.update()},!0)}}}),angular.module("WebCoreModule").directive("wcCheckAllNone",function(){return{restrict:"AE",require:"?^datatable",scope:{targetContainerId:"@targetContainerId"},template:'<a class="select-all" href="javascript:;" ng-click="checkAll()">{{"actions.selectAll" | translate}}</a> | <a class="select-none" href="javascript:;" ng-click="checkNone()">{{"actions.selectNone"| translate}}</a>',controller:["$scope",function($scope){$scope.toggleCheckAllExists=!1,$scope.setToggleCheckAllExists=function(exists){$scope.toggleCheckAllExists=exists},$scope.getToggleCheckAllExists=function(){return $scope.toggleCheckAllExists},/* Start Select All Functionality */
$scope.checkAll=function(){!$("#"+$scope.targetContainerId+" input.toggle-check-all").prop("checked")&&$scope.getToggleCheckAllExists()?($("#"+$scope.targetContainerId+" input.toggle-check-all").click(),console.log("CLICKING TOGGLE CHECK ALL")):$("#"+$scope.targetContainerId).find('input[type="checkbox"]:not(.toggle-check-all)').each(function(){var item=arguments[1],$item=$(item);$item.prop("checked")||$item.click()})},/* End Select All Functionality */
/* Start Select None Functionality */
$scope.checkNone=function(){$("#"+$scope.targetContainerId+" input.toggle-check-all").prop("checked")&&$scope.getToggleCheckAllExists()?($("#"+$scope.targetContainerId+" input.toggle-check-all").click(),console.log("un-CLICKING TOGGLE CHECK ALL")):$("#"+$scope.targetContainerId).find('input[type="checkbox"]:not(.toggle-check-all)').each(function(){var item=arguments[1],$item=$(item);$item.prop("checked")&&$item.click()})}}],link:["$scope","iElement","iAttrs","datatableController",function(){var $scope=arguments[0],datatableController=arguments[3];datatableController&&$scope.setToggleCheckAllExists(datatableController.getToggleCheckAllExists())}]}}),angular.module("WebCoreModule").directive("wcClickOnce",["$timeout",function($timeout){var delay=500;// min milliseconds between clicks
return{restrict:"A",priority:-1,// cause out postLink function to execute before native `ngClick`'s
// ensuring that we can stop the propagation of the 'click' event
// before it reaches `ngClick`'s listener
link:function(scope,elem){var disabled=!1,onClick=function(evt){disabled?(scope.$broadcast("onClickOnce"),evt.preventDefault(),evt.stopImmediatePropagation()):(disabled=!0,$timeout(function(){disabled=!1},delay,!1))};scope.$on("$destroy",function(){elem.off("click",onClick)}),elem.on("click",onClick)}}}]),angular.module("WebCoreModule").directive("wcContinueIfValid",["$timeout",function($timeout){return{restrict:"A",required:"^ngController",controller:["$state","$element","$scope",function($state,$element,$scope){
// jshint unused:true
//written as a function so we can mock it in test code
this.getWorkflowData=function(){return $state.$current.data.workflow},this.navigateToState=function(name,params,options){var callingValues={name:this.getWorkflowData().nextState,params:{},options:{location:!1,reload:!1}};
//if a single arg is passed, assume it's a state name and nav to it with other options as defaults
1==arguments.length?callingValues.name=name:arguments.length>1&&(name&&(callingValues.name=name),params&&(callingValues.params=params),options&&angular.extend(callingValues.options,options)),$state.go(callingValues.name,callingValues.params,callingValues.options)},this.clickHandler=angular.bind(this,function(viewCtrl){var callback=this.getWorkflowData().controllerContinueCallbackFunctionName;if(callback){var retVal=viewCtrl[callback]($element);retVal?
//async case
retVal.then?retVal.then(angular.bind(this,function(obj){this.navigateToState(obj.name,obj.params,obj.options)}),angular.bind(this,function(obj){this.navigateToState(obj.name,obj.params,obj.options)})):this.navigateToState(retVal.name,retVal.params,retVal.options):this.navigateToState()}else this.navigateToState()})}],link:function(scope,elem,attr,ctrl){
//these pieces aren't set up in a way that is easily unit testable.
//leave them here in the link and allow e2e testing to pick them up.
elem.on("click",function(){$timeout(function(){var viewCtrl=elem.controller(),formName=elem[0].form.name,formCtrl=scope.$parent[formName];
// enable display of validation errors
viewCtrl.isFormSubmitted=!0,
// if form is valid, navigate to requested state and call the given function
formCtrl.$valid&&ctrl.clickHandler(viewCtrl)},0)})}}}]),/**
 * @ngdoc directive
 * @name WebCoreModule.directive:wcFileUploadImage
 * @restrict E
 * @element div
 * @description
 * The wcFileUploadImage directive includes the html for upload photo.The upload can be done in two ways
 * one using uploading the image that is already available with the user and the other way is to take a photo
 * using the user's webcam and upload the image.
 */
angular.module("WebCoreModule").directive("wcFileUploadImage",function(){var template=['<div ng-show="ctrl.webcamPresent" class="row">','<div class="row">','<div class="col-md-3 col-md-offset-5" id="wc-file-upload-image-camera"></div>',"</div>",'<div class="row">','<div class="col-md-4 col-md-offset-5">','<button class="btn btn-tertiary " ng-click="ctrl.turnCameraOff()">Camera Off</button>','<button class="btn btn-tertiary" ng-click="ctrl.turnCameraOn()">Camera On</button>','<button class="btn btn-primary" ng-click="ctrl.capturePicture()">Take Picture</button>',"</div>","</div>","</div>",'<div class="row">','<div class="row">','<div class="col-md-3 col-md-offset-5">','<input wc-input-file="ctrl.chooseImageUpload" file-types="ctrl.fileTypes()" class="form-control" type="file" accept="image/">',"</div>","</div>",'<div class="row">','<div class="col-md-2 col-md-offset-5">','<button class="btn btn-primary" ng-click="ctrl.prepareForUpload()">Upload Photo</button>','<button class="btn btn-secondary" ng-click="ctrl.cancel()">Cancel</button>','<button class="btn btn-secondary" ng-click="ctrl.addImages()">Add Images</button>',"</div>","</div>","</div>"].join("");return{restrict:"E",scope:{},bindToController:{onUpload:"&",fileTypes:"&"},template:template,controllerAs:"ctrl",controller:["$rootScope","WcCameraService","WcImageFileService","WcDataFileService","$scope",function($rootScope,WcCameraService,WcImageFileService,WcDataFileService,$scope){this.cameraElement=$("#wc-file-upload-image-camera"),this.chooseImageUpload=null,this.snapshotToUpload=null,this.webcamPresent=!1,WcCameraService.checkForCamera().then(angular.bind(this,function(webCamIsPresnet){webCamIsPresnet&&(WcCameraService.setCameraSize(800,600),this.webcamPresent=!0)}))["catch"](function(error){console.log(error)}),this.cancel=function(){this.chooseImageUpload=null,this.snapshotToUpload=null,this.previewImageElement&&(this.previewImageElement.remove(),delete this.previewImageElement,this.cameraElement.append(this.videoElement),this.videoElement.get(0).play())},this.capturePicture=function(){var snapShot;0===this.cameraElement.find("img").length&&WcCameraService.cameraIsOn&&(snapShot=WcCameraService.takePicture(),this.previewImageElement=$("<img>").attr("src",snapShot),this.videoElement.remove(),this.cameraElement.append(this.previewImageElement),this.snapshotToUpload=snapShot)},this.prepareForUpload=function(){var imageToUpload=this.chooseImageUpload||this.snapshotToUpload,imageToUploadObject={};imageToUpload&&"string"!=typeof imageToUpload&&imageToUpload.length>0?WcDataFileService.readFile(imageToUpload[0]).then(function(imageURI){var imageFileData=WcDataFileService.prepareForFileUpload(imageURI);return imageToUploadObject.imageBase64String=imageFileData.base64String,imageToUploadObject.imageMIMEType=imageFileData.MIMEType,imageToUploadObject.fileType=WcDataFileService.getFileType(imageToUpload[0]),imageToUploadObject.description="...",WcImageFileService.createImageURI(imageURI)}).then(angular.bind(this,function(thumbnailURI){var thumbnailFileData=WcDataFileService.prepareForFileUpload(thumbnailURI);imageToUploadObject.thumbnailBase64String=thumbnailFileData.base64String,imageToUploadObject.thumbnailMIMEType=thumbnailFileData.MIMEType,this.onUpload({imageObject:imageToUploadObject}),this.cancel(),this.original=$("<img>").attr("src",imageToUploadObject.imageData),this.thumb=$("<img>").attr("src",thumbnailURI)})):"string"==typeof imageToUpload&&WcImageFileService.createImageURI(imageToUpload).then(angular.bind(this,function(thumbnailURI){imageToUploadObject.imageData=imageToUpload,imageToUploadObject.thumbnailData=thumbnailURI,imageToUploadObject.fileType="jpeg",imageToUploadObject.description="...",this.original=$("<img>").attr("src",imageToUploadObject.imageData),this.thumb=$("<img>").attr("src",imageToUploadObject.thumbnailData),this.onUpload({imageObject:imageToUploadObject}),this.cancel()}))},this.turnCameraOff=function(){WcCameraService.stopCamera(),this.videoElement.remove()},this.turnCameraOn=function(){this.webcamPresent&&!WcCameraService.cameraIsOn&&WcCameraService.returnVideoElement().then(angular.bind(this,function(videoElement){this.videoElement=videoElement,$("#wc-file-upload-image-camera").append(this.videoElement),WcCameraService.startCamera()}))["catch"](function(error){console.log(error)})}}],link:function(scope,element,attr,ctrl){ctrl.addImages=function(){element.append(ctrl.original),element.append(ctrl.thumb)}}}}),
// http://stackoverflow.com/questions/17063000/ng-model-for-input-type-file
angular.module("WebCoreModule").directive("wcInputFile",["_",function(_){return{scope:{},bindToController:{wcInputFile:"=",fileTypes:"&"},controllerAs:"ctrl",controller:["$scope","$element","WcDataFileService",function($scope,$element,WcDataFileService){var vm=this;this.onChange=function(changeEvent){
// TODO Just do one at a time
var fileTypes,files=changeEvent.target.files;$scope.$apply(function(){void 0!==vm.fileTypes()&&vm.fileTypes().length>0&&(fileTypes=_.map(files,function(item){var fileType=WcDataFileService.getFileType(item);return fileType}).filter(function(extension){return vm.fileTypes().indexOf(extension)>=0})),fileTypes&&fileTypes.length!==files.length?$element.val(null):vm.wcInputFile=files})}}],link:function(scope,element,attrs,ctrl){element.bind("change",ctrl.onChange),scope.$watch(function(){return ctrl.wcInputFile},function(file){console.log("log"),null===file&&element.val(null)})}}}]),/**
 * @ngdoc directive
 * @name WebCoreModule.directive:wcLoadingIndicator
 * @restrict A
 * @description
 * The wcLoadingIndicator directive includes the html for a visual loading indicator and a cover to prevent the user from
 * clicking on things as the app loads. The directive adds interceptors to the request/response process, which are used
 * to hide and show the indicator accordingly.
 */
angular.module("WebCoreModule").directive("wcLoadingIndicator",function(){return{restrict:"A",template:'<div id="loading-cover"></div><div id="loading-indicator"><span>Loading...</span></div>',controller:["$scope","WcHttpRequestService",function($scope,WcHttpRequestService){var requestCount=0,pendingStateChange=!1;return this.showLoadingIndicator=function(){$("#loading-cover").show().animate({opacity:1},300),$("#loading-indicator").show().animate({opacity:1},300)},this.hideLoadingIndicator=function(){$("#loading-indicator").hide().animate({opacity:0},10),$("#loading-cover").hide().animate({opacity:0},10)},this.incrementPendingCounterAndShow=angular.bind(this,function(){
//increment the counter
requestCount++,
//only call to show the indicator when incrementing from 0 to 1.
//will not need to do so for subsequent calls, as it will already be shown
1===requestCount&&this.showLoadingIndicator()}),this.decrementPendingCounterAndHide=angular.bind(this,function(){
//decrement the counter
requestCount--,
//only call to hide the indicator when decrementing from 1 to 0.
0===requestCount&&this.hideLoadingIndicator()}),WcHttpRequestService.addRequestInterceptor(angular.bind(this,function(){this.incrementPendingCounterAndShow()})),WcHttpRequestService.addErrorInterceptor(angular.bind(this,function(){pendingStateChange||this.decrementPendingCounterAndHide()})),WcHttpRequestService.addResponseInterceptor(angular.bind(this,function(){var data=arguments[0];return pendingStateChange||this.decrementPendingCounterAndHide(),data})),$scope.$on("$stateChangeStart",angular.bind(this,function(){pendingStateChange=!0})),this.hideLoadingIndicatorCallback=angular.bind(this,function(){requestCount=0,pendingStateChange=!1,this.hideLoadingIndicator()}),$scope.$on("$stateChangeError",this.hideLoadingIndicatorCallback),$scope.$on("$viewContentLoaded",this.hideLoadingIndicatorCallback),$scope.$on("Unauthenticated",this.hideLoadingIndicatorCallback),$scope.$on("Offline",this.hideLoadingIndicatorCallback),$scope.loadingIndicator=this}]}}),/**
 * @ngdoc directive
 * @name WebCoreModule.directive:wcNavMenu
 * @restrict A
 * @scope
 * @param {object} menuData The property to assign the menu data into so the view can access it
 * @param {array} menuDataUrl Array of objects defining the menu's structure and text
 * @description
 * The wcNavMenu directive generates a navigation menu from the given menu data url. The url should expose an array of objects
 * defining the menu's structure and text.
 */
angular.module("WebCoreModule").directive("wcNavMenu",["$compile",function($compile){return{restrict:"A",scope:{menuData:"=menuData",menuDataUrl:"@menuDataUrl"},transclude:!0,template:'<nav class="navbar navbar-default" role="navigation"><div class="navbar-header visible-xxs"><button id="toggle-nav-menu-collapse" type="button" class="navbar-toggle collapsed" ng-click="toggleNavbarCollpase()" aria-expanded="false"><span class="sr-only">{{\'application.navigation.toggleTitle\' | translate}}</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button></div><div uib-collapse="navbarCollapsed" class="collapse navbar-collapse" id="primary-nav" role="menu"><ul class="nav navbar-nav"><li role="menuitem" wc-protected-resource="{{menu.protected}}" ng-repeat="menu in menuData" ng-class="{dropdown:menu.secondaryNav}" ui-sref-active="active"><a ng-click="collapseNavbar()" ng-if="!menu.secondaryNav" ui-sref="{{menu.state | translate}}" ui-sref-opts="{reload: true, notify: true}">{{menu.label | translate}}</a><a ng-if="menu.secondaryNav" role="button" aria-expanded="false" href class="dropdown-toggle" data-toggle="dropdown">{{menu.label | translate}}<span ng-if="menu.secondaryNav" class="caret"></span></a><sub-menu-navigation></sub-menu-navigation></li></ul><span ng-transclude></span></div></nav>',controller:["$scope","$element","$attrs","$http",function($scope,$element,$attrs,$http){$scope.menuDataUrl&&$http.get($scope.menuDataUrl).success(function(response){$scope.menuData=response}),$scope.$on("$stateChangeStart",function(){$("nav .in, nav .open").removeClass("in open")}),$scope.$on("collapseNavBar",function(){$scope.collapseNavbar()}),$scope.navbarCollapsed=!0,$scope.toggleNavbarCollpase=function(){$scope.navbarCollapsed=!$scope.navbarCollapsed,$scope.navbarCollapsed?$("button.navbar-toggle").attr("aria-expanded","false"):$("button.navbar-toggle").attr("aria-expanded","true")},$scope.collapseNavbar=function(){$scope.navbarCollapsed||$scope.toggleNavbarCollpase()}}]}}]).directive("subMenuNavigation",["$compile",function($compile){return{restrict:"E",scope:!0,link:function(scope,element){if(scope.subMenu=scope.menu,scope.subMenu.secondaryNav&&scope.subMenu.secondaryNav.length){var template=angular.element('<ul class="dropdown-menu "><li wc-protected-resource="{{menu.protected}}" ng-repeat="menu in subMenu.secondaryNav"><a ui-sref="{{menu.state | translate}}" ui-sref-opts="{reload: true, notify: true}">{{menu.label | translate}}</a><sub-menu-navigation subMenu="menu"></sub-menu-navigation></li></ul>'),linkFunction=$compile(template);linkFunction(scope),element.replaceWith(template)}else element.remove()}}}]),
//credit to stack overflow for a lot of this one. http://stackoverflow.com/questions/24707508/angularjs-set-global-ngmodeloptions#answer-26537212
/**
 * @ngdoc directive
 * @name WebCoreModule.directive:ngModelDirective
 * @description
 * The ngModelDirective is a decorative directive mainly for HTML control operations,
 * this directive is responsible for set blur option in HTML fields.
 */
angular.module("WebCoreModule").config(["$provide",function($provide){$provide.decorator("ngModelDirective",["$delegate",function($delegate){var directive=$delegate[0],shouldSetBlurUpdateEvent=(directive.link,function(element){
// The blur event is only really applicable to input controls so
// we want to stick with the default events for selects, checkboxes & radio buttons.
// also stick with default events for typeahead controls and the ui-select
var nodeName=element.nodeName.toLowerCase();
//for some reason comments end up in here at times. short circuit this if that's the case.
if("#comment"==element.nodeName.toLowerCase())return!1;var nodeType=void 0;return"string"==typeof element.type&&(nodeType=element.type.toLowerCase()),"textarea"===nodeName&&!element.hasAttribute("maxlength")||"div"===nodeName&&!element.classList.contains("ui-select-bootstrap")&&!element.hasAttribute("wc-data-table") &&!element.hasAttribute("uib-datepicker-popup-wrap") ||"input"===nodeName&&"checkbox"!==nodeType&&"radio"!==nodeType&&!element.hasAttribute("typeahead")&&!element.hasAttribute("datepicker-popup")&&!element.hasAttribute("uib-datepicker-popup")}),compileFn=directive.compile;return directive.compile=function(){var link=compileFn.apply(this,arguments);return{pre:function(scope,element,attr,ctrls){
// jshint unused:true
ctrls[2]||(ctrls[2]={});var ngModelOptions=ctrls[2];void 0===ngModelOptions.$options&&shouldSetBlurUpdateEvent(element[0])&&(ngModelOptions.$options={updateOn:"blur",updateOnDefault:!1}),link.pre.apply(this,arguments)},post:link.post}},$delegate}])}]),angular.module("WebCoreModule").directive("wcOfflineIndicator",function(){return{restrict:"A",template:'<div><div id="offline-indicator" class="container-fluid" ng-switch="checking"><uib-alert type="warning"><span class="glyphicon glyphicon-warning-sign" ng-switch-when="false"></span><span class="glyphicon glyphicon-refresh glyphicon-refresh-animate" ng-switch-when="true"></span><span>{{\'offlineIndicator.offlineMessage\'|translate}} <a href ng-click="checkNetworkState()">{{\'offlineIndicator.retryConnection\'|translate}}</a></span></uib-alert></div><div id="unavailable-offline" class="container-fluid" ng-switch="checking"><uib-alert type="danger"><span class="glyphicon glyphicon-remove-circle" ng-switch-when="false"></span><span class="glyphicon glyphicon-refresh glyphicon-refresh-animate" ng-switch-when="true"></span><span>{{\'offlineIndicator.unavailableMessage\'|translate}} <a href ng-click="checkNetworkState()">{{\'offlineIndicator.retryConnection\'|translate}}</a></span></uib-alert></div><div id="unauth-indicator" class="container-fluid" ng-switch="checking"><uib-alert type="warning"><span class="glyphicon glyphicon-warning-sign" ng-switch-when="false"></span><span class="glyphicon glyphicon-refresh glyphicon-refresh-animate" ng-switch-when="true"></span><span>{{\'unauthIndicator.unauthMessage\'|translate}} <a href ng-click="wslLogin()">{{\'unauthIndicator.wslLogin\'|translate}}</a></span></uib-alert></div></div>',replace:!0,controller:["WcHttpRequestService","$scope","$window","$timeout","$state","WcTranslateConfiguratorService","Constants",function(WcHttpRequestService,$scope,$window,$timeout,$state,WcTranslateConfiguratorService,Constants){
// Ensure directive is hidden initially
return WcTranslateConfiguratorService.loadPartAndRefresh("WC-offlineIndicator"),$("#offline-indicator").hide(),$("#unavailable-offline").hide(),$("#unauth-indicator").hide(),$scope.checking=!1,this.showOfflineIndicator=function(){$("#offline-indicator").show();var alertBox=$("#offline-indicator .alert");alertBox.addClass("pulse"),$timeout(function(){alertBox.removeClass("pulse")},2e3),$window.scrollTo(0,1)},this.hideOfflineIndicator=function(){$("#offline-indicator").hide()},this.showUnavailableOffline=function(){$("#unavailable-offline").show();var alertBox=$("#unavailable-offline .alert");alertBox.addClass("pulse"),$timeout(function(){alertBox.removeClass("pulse")},2e3),$window.scrollTo(0,1)},this.hideUnavailableOffline=function(){$("#unavailable-offline").hide()},this.showUnauthIndicator=function(){$("#unauth-indicator").show();var alertBox=$("#unauth-indicator .alert");alertBox.addClass("pulse"),$timeout(function(){alertBox.removeClass("pulse")},2e3),$window.scrollTo(0,1)},this.hideUnauthIndicator=function(){$("#unauth-indicator").hide()},$scope.checkNetworkState=function(){$scope.checking=!0,WcHttpRequestService.getNetworkState().then(function(state){
//after clicking the check link, force a redirect to wsl if needed
"unauthenticated"==state&&$scope.wslLogin(),$scope.checking=!1})},$scope.wslLogin=function(){$window.location.href=Constants.wslBaseUrl+encodeURIComponent($window.location.href)},WcHttpRequestService.addResponseInterceptor(angular.bind(this,function(){
// hide indicators if we have a successful ReST response
this.hideOfflineIndicator(),this.hideUnavailableOffline(),this.hideUnauthIndicator()})),$scope.$on("Offline",angular.bind(this,function(){$state.current.data&&$state.current.data.unavailableOffline?(this.hideOfflineIndicator(),this.showUnavailableOffline(),this.hideUnauthIndicator()):(this.showOfflineIndicator(),this.hideUnavailableOffline(),this.hideUnauthIndicator())})),$scope.$on("Unauthenticated",angular.bind(this,function(){this.showUnauthIndicator(),this.hideOfflineIndicator(),this.hideUnavailableOffline()})),$scope.offlineIndicator=this}]}}),angular.module("WebCoreModule").directive("wcPageTitle",function(){return{restrict:"A",controller:["$scope","$state","$compile",function($scope,$state,$compile){var firstRun=!0;$scope.pageTitle="",this.cleanUpName=function(name){var cleanName=name;return cleanName=cleanName.replace(/-/g," "),cleanName=cleanName.replace(/\b./g,function(m){return m.toUpperCase()})},this.updatePageTitle=function(){
// grab app name
var parentStateName,appName=$("#ng-app").attr("ng-app").replace("Module",""),stateName=this.cleanUpName($state.$current.name);$state.$current.parent&&(parentStateName=this.cleanUpName($state.get($state.$current.parent).name));var tempPageTitle;tempPageTitle=parentStateName&&parentStateName.replace(/ /g,"")!=appName?parentStateName+": "+stateName+" | "+appName:stateName+" | "+appName,$scope.pageTitle=tempPageTitle},$scope.$on("$viewContentLoaded",angular.bind(this,function(){if(firstRun){var titleTag=$("title").attr({"wc-page-title":"","ng-bind":"pageTitle"});titleTag.replaceWith($compile(titleTag)($scope)),firstRun=!1}this.updatePageTitle()}))}]}}),angular.module("WebCoreModule").directive("wcPagination",["$templateCache","$compile",function($templateCache,$compile){return{restrict:"A",priority:1,scope:{wcPagination:"=",location:"@",resultsPerPage:"&",resultsPerPageText:"@",showingResultsText:"@",resultsItemCount:"&",responsiveBreakpoints:"&"},controller:["$scope","$window","_",function($scope,$window,_){$scope.searchResults=$scope.wcPagination,angular.isArray($scope.resultsPerPage())?$scope.resultsPerPage=$scope.resultsPerPage():$scope.resultsPerPage=[10,25,50,100],angular.isArray($scope.responsiveBreakpoints())?$scope.responsiveBreakpoints=$scope.responsiveBreakpoints():$scope.responsiveBreakpoints=[430,500,600,900],$scope.resultsPerPageText||($scope.resultsPerPageText="Results per page: "),$scope.showingResultsText||($scope.showingResultsText="Showing results "),angular.isNumber($scope.resultsItemCount())?$scope.resultsItemCount=$scope.resultsItemCount():$scope.resultsItemCount=$scope.resultsPerPage[0],$scope.totalItems=$scope.searchResults.length,$scope.itemsPerPage=$scope.resultsItemCount,$scope.currentPage=1,$scope.boundaryLinks=!0,$scope.maxSize=5,$scope.filteredSearchResults=[],$scope.updatePageResultsCount=function(){$scope.itemsPerPage=$scope.resultsItemCount},$scope.begin=1,$scope.end=$scope.begin+$scope.itemsPerPage,$scope.$watchCollection(function(){return $scope.currentPage+$scope.itemsPerPage},function(){$scope.begin=($scope.currentPage-1)*$scope.itemsPerPage,$scope.end=$scope.begin+$scope.itemsPerPage,$scope.end>$scope.totalItems&&($scope.end=$scope.totalItems),$scope.wcPagination=$scope.searchResults.slice($scope.begin,$scope.end),$window.scrollTo(0,1)}),$scope.currentBreakpoint="",
//responsive stuff
$scope.$watch(function(){return $scope.currentBreakpoint},function(newValue,oldValue){newValue!=oldValue&&("xs"==newValue?($(".pagination-row").addClass("hidden"),$scope.itemsPerPage=$scope.searchResults.length,$scope.maxSize=0,$scope.boundaryLinks=!1):"sm"==newValue?($(".pagination-row").removeClass("hidden"),$scope.itemsPerPage=$scope.resultsItemCount,$scope.maxSize=0,$scope.boundaryLinks=!1):"md"==newValue?($(".pagination-row").removeClass("hidden"),$scope.itemsPerPage=$scope.resultsItemCount,$scope.maxSize=0,$scope.boundaryLinks=!1):"lg"==newValue?($(".pagination-row").removeClass("hidden"),$scope.itemsPerPage=$scope.resultsItemCount,$scope.maxSize=1,$scope.boundaryLinks=!0):($scope.maxSize=5,$scope.boundaryLinks=!0))});var resizeHandler=function(){
//<=430 is default
window.innerWidth<=$scope.responsiveBreakpoints[0]&&"xs"!=$scope.currentBreakpoint?($scope.currentBreakpoint="xs",$scope.$apply()):window.innerWidth>$scope.responsiveBreakpoints[0]&&window.innerWidth<=$scope.responsiveBreakpoints[1]&&"sm"!=$scope.currentBreakpoint?($scope.currentBreakpoint="sm",$scope.$apply()):window.innerWidth>$scope.responsiveBreakpoints[1]&&window.innerWidth<=$scope.responsiveBreakpoints[2]&&"md"!=$scope.currentBreakpoint?($scope.currentBreakpoint="md",$scope.$apply()):window.innerWidth>$scope.responsiveBreakpoints[2]&&window.innerWidth<=$scope.responsiveBreakpoints[3]&&"lg"!=$scope.currentBreakpoint?($scope.currentBreakpoint="lg",$scope.$apply()):window.innerWidth>$scope.responsiveBreakpoints[3]&&"xl"!=$scope.currentBreakpoint&&($scope.currentBreakpoint="xl",$scope.$apply())};
//debounce this handler to avoid rapid-fire resize events
angular.element($window).bind("resize",_.debounce(resizeHandler,300)),
//finally, call the resizeHandler once to initialize our breakpoint var
setTimeout(resizeHandler,0)}],link:function(scope,elem){
//leave template here instead of in it's own file, as it's difficult to load the template properly from a file for this type of inclusion.
var templateTop='<div class="row pagination-row"><div class="col-sm-4 col-xs-6"><label for="results-per-page-top" class="control-label">{{resultsPerPageText}}</label><select ng-model="resultsItemCount" ng-options="result for result in resultsPerPage" id="results-per-page-top" name="resultsPerPage" ng-change="updatePageResultsCount();"></select></div><div class="col-sm-4 hidden-xs text-center results-data">{{showingResultsText}} {{begin+1}}-{{end}} of {{totalItems}}</div><div class="col-sm-4 col-xs-6 text-right"><pagination total-items="totalItems" items-per-page="resultsItemCount" ng-model="currentPage" max-size="maxSize" boundary-links="boundaryLinks" previous-text="&#xe071" next-text="&#xe075" first-text="&#xe069" last-text="&#xe077"></pagination></div></div>',templateBottom='<div class="row pagination-row"><div class="col-sm-4 col-xs-6"><label for="results-per-page-bottom" class="control-label">{{resultsPerPageText}}</label><select ng-model="resultsItemCount" ng-options="result for result in resultsPerPage" id="results-per-page-bottom" name="resultsPerPage" ng-change="updatePageResultsCount();"></select></div><div class="col-sm-4 hidden-xs text-center results-data">{{showingResultsText}} {{begin+1}}-{{end}} of {{totalItems}}</div><div class="col-sm-4 col-xs-6 text-right"><pagination total-items="totalItems" items-per-page="resultsItemCount" ng-model="currentPage" max-size="maxSize" boundary-links="boundaryLinks" previous-text="&#xe071" next-text="&#xe075" first-text="&#xe069" last-text="&#xe077"></pagination></div></div>';"top"!=scope.location&&"both"!=scope.location||elem.before($compile(templateTop)(scope)),"bottom"!=scope.location&&"both"!=scope.location||elem.after($compile(templateBottom)(scope))}}}]),angular.module("WebCoreModule").directive("wcProtectedResource",function(){return{priority:-500,restrict:"A",require:["wcProtectedResource","?^wcDataTable"],controller:["WcAuthorizationService","$element","$attrs",function(WcAuthorizationService,$element,$attrs){this.checkAuthorization=function(){var criteria=null,policies=$attrs.wcProtectedResource;if(policies){
// check to see if we have an authorization criteria in-line
policies.indexOf("|")>-1&&(
// extract "any" or "all"
criteria=policies.slice(policies.indexOf("|")+1,policies.length).toString().trim()),
// if we have a criteria, clean up string so we can easily extract policies
criteria&&(policies=policies.slice(0,policies.indexOf("|"))),
// support multiple policies
policies=policies.split(",");
// remove whitespace
for(var i=0;i<policies.length;i++)policies[i]=policies[i].trim()}else policies=[];var isAuth=WcAuthorizationService.isAuthorized(policies,criteria);isAuth.then(function(authorized){authorized===!1&&$element.remove()})}}],compile:function(){return{post:function(){var controllers=arguments[3],protectedResourceCtrl=controllers[0],datatableCtrl=controllers[1];datatableCtrl&&(datatableCtrl.checkAuthorization=protectedResourceCtrl.checkAuthorization()),protectedResourceCtrl.checkAuthorization()}}}}}),angular.module("WebCoreModule").directive("wcValidationIndicator",["_","$translate","$timeout",function(_,$translate,$timeout){return{restrict:"A",priority:1,link:function(scope,elem,attr,ctrl){
//wrap in timeout of zero seconds to force a digest. This ensures nested directives finish before the indicator directive runs
$timeout(function(){
//fieldset is caps here thanks to the browser defining it that way
elem[0].form&&"FIELDSET"!=elem[0].tagName||(elem=$(elem).find("input"));
// add for other input types
// var elementTypesToValidate = ['input', 'textarea', 'select', 'form'],
var ngFormObj,formName=elem[0].form.name;
//modals use ctrl.form.formName instead of ctrl.formName
//handle it here
formName.indexOf(".")>-1?(formName=formName.split("."),ngFormObj=scope.$parent[formName[0]][formName[1]]):
//break out of isolate scope and then walk the tree for the form obj
ngFormObj=scope.$parent[formName];var elemName=elem[0].name;
//sometimes the reset element will not carry the name attr (I'm looking at you, ui-select).
//in this case, instead grab it off of the attr object that was passed in
elemName||(elemName=attr.name,elemName||""==attr.wcResponsiveTable&&(elemName="wcResponsiveTable"));var elemCtrl;
//need to select the controller in a different way if we are within a modal
if(angular.isArray(formName)){
//take the controller's name off of the ng-model.
//todo - if there's a better way to do this, DO IT!!
var ctrlName=elem[0].attributes["ng-model"].nodeValue.split(".")[0];elemCtrl=scope.$parent[ctrlName]}else elemCtrl=elem.controller();var formGroup=$(elem).closest(".form-group")[0];
//datatables will not be in a formgroup. add one and refer to it
formGroup||(formGroup=$('<div class="form-group"></div>').insertBefore("#"+elem.context.attributes.id.value));var errType,errorMessage,errorMessageDOM,n,min,max,validatorAttrs,errorMsgId,fieldNameTranslateString=attr.wcValidationIndicator,errorTypes={defaultMsg:"Please add error message for {{n}}.",email:"Please enter a valid email address.",minlength:"Please enter at least {{n}} characters.",maxlength:"You have entered more than {{n}} characters.",min:"Please enter the number greater than {{n}}.",max:"Please enter the number lesser than {{n}}.",minMaxRange:"Please enter between {{min}} and {{max}}.",required:"{{fieldName}} is required.",tableRequired:"{{fieldName}} is required.",date:"Please enter a valid date.",pattern:"The pattern entered is incorrect.",number:"Please enter a valid number.",url:"Please enter a valid URL.",inValid:"{{fieldName}} is invalid."},buildErrorMsg=function(errType){validatorAttrs.length>0?errorMessage=ngFormObj[elemName].$error.hasOwnProperty("required")?$translate.instant(errorTypes.required,{fieldName:fieldNameTranslateString}):$translate.instant(errorTypes.inValid,{fieldName:fieldNameTranslateString}):(n=attr[errType],("min"===errType||"max"===errType)&&attr.min&&attr.max&&(errType="minMaxRange",min=attr.min,max=attr.max),errorMessage=$translate.instant(errorTypes[errType],{n:n,fieldName:fieldNameTranslateString,min:min,max:max}))},elemNameSnakeCase=elemName.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();errorMsgId=elemNameSnakeCase+"-error";var buildErrorMsgDOM=function(errType){buildErrorMsg(errType),errorMessageDOM=$('<span id="'+errorMsgId+'" class="label label-danger"><span class="glyphicon glyphicon-remove-sign"></span><span class="label-text">'+errorMessage+"</span></span>")},watchListener=function(){
//when the validation error occurs, insert the error messages and mark the container
if(
//first, remove potential leftover messages.
$(formGroup).find("#"+errorMsgId).remove(),!ngFormObj[elemName].$valid&&elemCtrl.isFormSubmitted){validatorAttrs=_.filter(_.keys(attr),function(item){return item.indexOf("Validator")>-1});for(var errorCases=_.pairs(ngFormObj[elemName].$error),i=0;i<errorCases.length;i++)errType=errorCases[i][0],buildErrorMsgDOM(errType);$(formGroup).append(errorMessageDOM),$(formGroup).addClass("has-error")}else $(formGroup).removeClass("has-error"),$(formGroup).find("#"+errorMsgId).remove()};scope.$watch(function(){return ngFormObj[elemName].$valid},function(){watchListener()}),scope.$watch(function(){return elemCtrl.isFormSubmitted},function(){watchListener()}),scope.$watch(function(){return ngFormObj[elemName].$error},function(){watchListener()},!0)},0)}}}]),angular.module("WebCoreModule").directive("wcDataTable",["$compile","$window","_",function($compile,$window,_){return{restrict:"A",require:["wcDataTable","?ngModel"],scope:{headerTemplate:"@headerTemplate",overrideOptions:"@wcDataTable",columns:"=columns",columnDefs:"@columnDefs",responsiveColumnDefs:"@responsiveColumnDefs",data:"=data",checkBoxCol:"@checkBoxCol",radioButtonCol:"@radioButtonCol",selectedValue:"@selectedValue",ngModel:"=ngModel",name:"@name"},transclude:!0,replace:!0,template:"<div ng-transclude></div>",controller:["$compile","$scope","$element","$attrs","WcDataTableService",function($compile,$scope,$element,$attrs,WcDataTableService){this.defaultOptions={bAutoWidth:!1,bStateSave:!1,bPaginate:!0,sPaginationType:"bootstrap_full_numbers",sDom:'<"row paginator paginator-top"<"col-xs-3"l><"col-xs-4 text-right"i><"col-xs-5 text-right"p>>t<"row paginator paginator-bottom"<"col-xs-3"l><"col-xs-4 text-right"i><"col-xs-5 text-right"p>>>',bLengthChange:!0,bFilter:!1,bDestroy:!0,fnCreatedRow:function(row,data,dataIndex){
// jshint unused:true
var theRow=$(row)[0],theCells=$(theRow).find("td"),cellWithLinks=$($(theCells)[0]);
// updated clickedRowData
$(theRow).find("a, button").on("click",angular.bind(this,function(){
// use index to find value in original data set because mRender could have overwritten the local copy
WcDataTableService.setClickedRowData($scope.data[dataIndex])})),
//we only compile the first cell in each row, as this currently is the only location for angular controls
$compile(cellWithLinks.contents())($scope.$parent)},aaSorting:[[2,"asc"]]},this.options={},this.useResponsiveColumns=!1,this.currentBreakpoint=-1,this.previousBreakPoint=-1,this.toggleCheckAll=$scope.checkBoxCol==parseInt($scope.checkBoxCol),this.checkAuthorization=function(){},this.getToggleCheckAllExists=function(){return this.toggleCheckAll},this.initialize=function(ngModelController){
//first thing - redirect the alert warnings to the console
//credit to stack overflow poster 'orad': http://stackoverflow.com/questions/11941876/correctly-suppressing-warnings-in-datatables
$window.alert=function(){var nativeAlert=$window.alert;return function(message){$window.alert=nativeAlert,0===message.indexOf("DataTables warning")?console.warn(message):nativeAlert(message)}}(),this.table=$element.find("table");
// apply DataTable options, use defaults if none specified by user
var options={};if($scope.overrideOptions&&(options=$scope.$eval($scope.overrideOptions)),
//column configuration
$scope.columns&&(options.aoColumns=angular.copy($scope.columns)),this.showcheckBoxColumn=$scope.checkBoxCol==parseInt($scope.checkBoxCol),this.showRadioColumn=$scope.radioButtonCol==parseInt($scope.radioButtonCol),this.inValidCombination=this.showcheckBoxColumn&&this.showRadioColumn,this.hasInputField=this.showcheckBoxColumn||this.showRadioColumn,this.inValidCombination){var errorMessage="YOU CANNOT HAVE A DATATABLE WITH BOTH A CHECKBOX COLUMN AND A RADIOBUTTON COLUMN - IT MESSES WITH THE DATA";return console.error(errorMessage),$element.prepend('<div class="alert alert-danger"><td colspan=""><p>'+errorMessage+"</p></div>"),!1}
// Build required text for input attributes
var requiredString=$attrs.required?"required":"",inputName=$scope.name?'name="'+$scope.name+'"':"";
// Error msg if has input field without ng-model
if(this.hasInputField&&!$attrs.ngModel){var errorMessage='Must define the "ng-model" attribute IF a checkbox or radio column index is defined.';console.error(errorMessage),$element.prepend('<div class="alert alert-danger"><td colspan=""><p>'+errorMessage+"</p></div>")}
// Error msg if has input field without name
if(this.hasInputField&&!inputName){var errorMessage='Must define the "name" attribute IF a checkbox or radio column index is defined.';console.error(errorMessage),$element.prepend('<div class="alert alert-danger"><td colspan=""><p>'+errorMessage+"</p></div>")}
// Error msg if has input field without the selected value (primary key)
if(this.hasInputField&&!$scope.selectedValue){var errorMessage='Must define the "selected-value" attribute IF a checkbox or radio column index is defined.';console.error(errorMessage),$element.prepend('<div class="alert alert-danger"><td colspan=""><p>'+errorMessage+"</p></div>")}
// Error msg if required without input field
if(!this.hasInputField&&requiredString){var errorMessage="Must define a checkbox or radio column index IF the HTML5 required attribute is set";console.error(errorMessage),$element.prepend('<div class="alert alert-danger"><td colspan=""><p>'+errorMessage+"</p></div>")}
//CheckBox column
if(this.showcheckBoxColumn){//so that check boxes show even if chosen column is index 0
var checkBoxCol={sTitle:'<input type="checkbox" id="toggleAll" class="toggle-check-all"/><label for="toggleAll" class="hidden">Toggle Check All</label>',sClass:"text-center",mData:$scope.selectedValue,mRender:function(data,type,full){return angular.toJson(data)==angular.toJson(full[$scope.selectedValue])&&-1==new String(full[$scope.selectedValue]).indexOf("<label")?'<label class="sr-only" for="checkbox_'+full[$scope.selectedValue]+'">Select '+full[$scope.selectedValue]+'</label><input type="checkbox" id="checkbox_'+full[$scope.selectedValue]+'" '+inputName+" "+requiredString+' class="checkbox table-check-box" value="'+full[$scope.selectedValue]+'"/>':data},bSortable:!1};angular.toJson(options.aoColumns[$scope.checkBoxCol])!=angular.toJson(checkBoxCol)&&
//check if checkbox column is already here, so we don't add it multiple times
options.aoColumns.splice($scope.checkBoxCol,0,checkBoxCol),$(this.table).addClass("table-toggle-check-all")}
//RadioButton column
if(this.showRadioColumn){//so that radio buttons show even if chosen column is index 0
var radioButtonCol={sTitle:"",sClass:"text-center",mData:$scope.selectedValue,mRender:function(data){return data?'<label class="sr-only" for="radio_'+data+'">Select '+data+'</label><input type="radio" id="radio_'+data+'" '+inputName+" "+requiredString+' class="radio table-radio-button" value="'+data+'"/>':""},bSortable:!1};angular.toJson(options.aoColumns[$scope.radioButtonCol])!=angular.toJson(radioButtonCol)&&
//check if radioButton column is already here, so we don't add it multiple times
options.aoColumns.splice($scope.radioButtonCol,0,radioButtonCol)}if(
//column configuration
$scope.columnDefs&&(options.aoColumnDefs=$scope.$eval($scope.columnDefs)),$scope.responsiveColumnDefs){if(this.responsiveColumnDefs=$scope.$eval($scope.responsiveColumnDefs),void 0===this.responsiveColumnDefs.initial)throw"DataTables Error: No initial state defined.";this.useResponsiveColumns=!0,this.maxBreakpoint=_.max(this.responsiveColumnDefs.breakpoints)}
// pass options to dataTable
// on data change, redo directive with original DOM
return this.defineTable(options),$scope.data&&(this.dataTable.fnAddData($scope.data),$scope.$watch(function(){return $scope.data},angular.bind(this,function(oldVal,newVal){oldVal!=newVal&&(this.defineTable(this.options),this.dataTable.fnClearTable(),this.dataTable.fnAddData($scope.data),this.createInputColumn(ngModelController))}))),this.createInputColumn=function(ngModelController){var jqTable=$(this.table);if(this.showRadioColumn){var rows=this.table.fnGetNodes();
//check if there is a radio button already selected
$scope.$parent.$eval($attrs.ngModel)&&($(rows).find("input[id=radio_"+$scope.$parent.$eval($attrs.ngModel)+"]").prop("checked",!0),$(rows).find("input[id=radio_"+$scope.$parent.$eval($attrs.ngModel)+"]").parent().parent().addClass("selected")),angular.element($(rows).find(".table-radio-button")).on("change",function(){$.each(rows,function(){$(this).removeClass("selected"),$(this).find('input[type="radio"]').prop("checked",!1)}),$(this).parent().parent().addClass("selected"),$(this).prop("checked",!0),ngModelController.$setViewValue($(this).val()),$scope.$apply()})}if(this.showcheckBoxColumn){$(this.table).addClass("table-toggle-check-all");var latestChecked,oldView=[],newView=[],rows=this.table.fnGetNodes();
//check if there are check boxes already selected
$scope.$parent.$eval($attrs.ngModel)&&angular.forEach($scope.$parent.$eval($attrs.ngModel),function(item){$(rows).find("input[id=checkbox_"+item+"]").prop("checked",!0),$(rows).find("input[id=checkbox_"+item+"]").parent().parent().addClass("selected")}),angular.element($(rows).find(".table-check-box")).on("change",function(){ngModelController.$viewValue?this.checked?(//checking a box
$(this).parent().parent().addClass("selected"),oldView=ngModelController.$viewValue,latestChecked=[$(this).val()],newView=_.uniq(oldView.concat(latestChecked)),ngModelController.$setViewValue(newView)):($(this).parent().parent().removeClass("selected"),newView=_.without(ngModelController.$viewValue,$(this).val()),ngModelController.$setViewValue(newView)):($(this).parent().parent().addClass("selected"),ngModelController.$setViewValue([$(this).val()]));/* -----Start Toggle Check All Functionality -------*/
var numCheckBoxes=jqTable.find(".table-check-box").length,numSelectedRows=jqTable.find(".selected").length;numCheckBoxes==numSelectedRows?jqTable.find("thead th input.toggle-check-all").prop("checked",!0):jqTable.find("thead th input.toggle-check-all").prop("checked",!1),"$apply"!=$scope.$root.$$phase&&"$digest"!=$scope.$root.$$phase&&
//avoid $scope.apply is already in progress error
$scope.$apply()}),angular.element(jqTable.find("thead th input.toggle-check-all")).on("change",function(){this.checked?//checking the box
$.each(jqTable.find(".table-check-box"),function(){0==$(this).prop("checked")&&$(this).click()})://un-checking the box
$.each(jqTable.find(".table-check-box"),function(){$(this).prop("checked")&&$(this).click()})}),
//check or uncheck the toggle check all box on pagination and resize
this.table.bind("draw",function(){var numCheckBoxes=jqTable.find(".table-check-box").length,numSelectedRows=jqTable.find(".selected").length;numCheckBoxes==numSelectedRows?jqTable.find("thead th input.toggle-check-all").prop("checked",!0):jqTable.find("thead th input.toggle-check-all").prop("checked",!1)})}},!0},this.defineTable=function(options){options=_.defaults(options,this.defaultOptions),angular.extend(this.options,options),this.dataTable&&this.dataTable.fnDestroy(),this.dataTable=this.table.dataTable(this.options)},this.adjustColumns=function(){var settings=this.dataTable.fnSettings(),options={},columnsToHide=null;$($window).width()>this.maxBreakpoint&&(this.previousBreakPoint=this.currentBreakPoint,this.currentBreakPoint=-1,columnsToHide=this.responsiveColumnDefs.initial.columns,options={bPaginate:this.responsiveColumnDefs.initial.paging,sDom:this.responsiveColumnDefs.initial.dom,sPaginationType:this.responsiveColumnDefs.initial.pagination,oLanguage:{oPaginate:{sShowPagingText:this.responsiveColumnDefs.initial.showPagingText}}});for(var i=0;i<=this.responsiveColumnDefs.breakpoints.length;i++)if($($window).width()<this.responsiveColumnDefs.breakpoints[i]){this.previousBreakPoint=this.currentBreakPoint,this.currentBreakPoint=this.responsiveColumnDefs.breakpoints[i],columnsToHide=this.responsiveColumnDefs.columns[i],options={bPaginate:this.responsiveColumnDefs.paging[i],sDom:this.responsiveColumnDefs.dom[i],sPaginationType:this.responsiveColumnDefs.pagination[i],oLanguage:{oPaginate:{sShowPagingText:this.responsiveColumnDefs.showPagingText[i]}}};break}if(this.currentBreakPoint!==this.previousBreakPoint){
//credit to stack overflow posters 'Michael Herold and Ryan O'Neill': http://stackoverflow.com/a/15311842
var paginationOptions=angular.merge(this.options,options);this.defineTable(paginationOptions);for(var i=0;i<settings.aoColumns.length;i++)_.contains(columnsToHide,i)?this.dataTable.fnSetColumnVis(i,!1):settings.aoColumns[i].bVisible||this.dataTable.fnSetColumnVis(i,!0);$element.find(".paginator select").addClass("form-control input-sm")}}}],compile:function(){var TEMPLATE_REGEXP=/<.+>/;return{pre:function($scope,iElement){if($scope.headerTemplate){var headerTemplate=$scope.headerTemplate;headerTemplate&&!TEMPLATE_REGEXP.test(headerTemplate)&&(headerTemplate=$.ajax({type:"GET",url:headerTemplate,async:!1}).responseText),headerTemplate=angular.element(headerTemplate),$compile(headerTemplate)($scope);var table=iElement.find("table"),thead=table.find("thead");thead.exists()?thead.replaceWith(headerTemplate):table.append(headerTemplate)}},post:function($scope,iElement,iAttrs,controllers){
// jshint unused:true
var datatableController=controllers[0],ngModelController=controllers[1];datatableController.initialize(ngModelController)&&(datatableController.useResponsiveColumns&&(datatableController.adjustColumns(),angular.element($window).bind("resize",function(){datatableController.adjustColumns(),datatableController.createInputColumn(ngModelController),$scope.$apply()})),datatableController.createInputColumn(ngModelController))}}}}}]),angular.module("WebCoreModule").service("WcDataTableService",["$q",function($q){var clickedRowData={};this.setClickedRowData=function(data){clickedRowData=data},this.getClickedRowData=function(){return $q.when(clickedRowData)}}]),/**
 * @ngdoc directive
 * @name dataTabls.bootstrap.paging
 * @description
 * This directive is responsible for all the paging operation in data table, the module generates
 * the paging HTML block that is rendered in data table
 */
/* Set the defaults for DataTables initialisation */
$.extend(!0,$.fn.dataTable.defaults,{sDom:"<'row paginator'<'col-xs-6'l><'col-xs-6'f>r>t<'row paginator'<'col-xs-6'i><'col-xs-6'p>>",sPaginationType:"bootstrap_full_numbers",oLanguage:{sLengthMenu:"Results per page: _MENU_",sInfo:"Showing Results: _START_ - _END_ of _TOTAL_"}}),/* Default class modification */
$.extend($.fn.dataTableExt.oStdClasses,{sWrapper:"dataTables_wrapper form-inline"}),/* Bootstrap style pagination control */
$.extend($.fn.dataTableExt.oPagination,{bootstrap_two_button:{fnInit:function(oSettings,nPaging,fnCallbackDraw){var oLang=oSettings.oLanguage.oPaginate,oClasses=oSettings.oClasses,disabledClass="disabled "+oClasses.sPageButtonStaticDisabled,sAppend='<ul class="pagination"><li class="previous '+disabledClass+'"><a href="javascript:;" class="'+oClasses.sPageButton+" "+oClasses.sPagePrevious+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oClasses.sPagePreviousText+'">'+oLang.sPrevious+'</span></a></li><li class="next '+disabledClass+'"><a href="javascript:;" class="'+oClasses.sPageButton+" "+oClasses.sPageNext+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oClasses.sPageNextText+'">'+oLang.sNext+"</span></a></li></ul>";$(nPaging).append(sAppend);var els=$("a",nPaging),nPrevious=els[0],nNext=els[1];/* ID the first elements only */
oSettings.aanFeatures.p||(nPaging.id=oSettings.sTableId+"_paginate",nPrevious.id=oSettings.sTableId+"_previous",nNext.id=oSettings.sTableId+"_next",nPrevious.setAttribute("aria-controls",oSettings.sTableId),nNext.setAttribute("aria-controls",oSettings.sTableId));var fnClickHandler=function(e){e.preventDefault(),oSettings.oApi._fnPageChange(oSettings,e.data.action)&&fnCallbackDraw(oSettings)};oSettings.oApi._fnBindAction(nPrevious,{action:"previous"},fnClickHandler),oSettings.oApi._fnBindAction(nNext,{action:"next"},fnClickHandler)},fnUpdate:function(oSettings){if(oSettings.aanFeatures.p)for(var iPages=Math.ceil(oSettings.fnRecordsDisplay()/oSettings._iDisplayLength),iCurrentPage=Math.ceil(oSettings._iDisplayStart/oSettings._iDisplayLength)+1,oClasses=oSettings.oClasses,disabledClass="disabled "+oClasses.sPageButtonStaticDisabled,an=oSettings.aanFeatures.p,i=0;i<an.length;i++)/* Update the permanent button's classes */
1==iCurrentPage?$("li:eq(0)",an[i]).addClass(disabledClass):$("li:eq(0)",an[i]).removeClass(disabledClass),0===iPages||iCurrentPage===iPages||-1===oSettings._iDisplayLength?$("li:eq(-1)",an[i]).addClass(disabledClass):$("li:eq(-1)",an[i]).removeClass(disabledClass)}},bootstrap_normal:{fnInit:function(oSettings,nPaging,fnCallbackDraw){var oLang=oSettings.oLanguage.oPaginate,oClasses=oSettings.oClasses,disabledClass="disabled "+oClasses.sPageButtonStaticDisabled,sAppend='<ul class="pagination"><li class="previous '+disabledClass+'"><a href="javascript:;" class="'+oClasses.sPageButton+" "+oClasses.sPagePrevious+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oClasses.sPagePreviousText+'">'+oLang.sPrevious+'</span></a></li><li class="next '+disabledClass+'"><a href="javascript:;" class="'+oClasses.sPageButton+" "+oClasses.sPageNext+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oClasses.sPageNextText+'">'+oLang.sNext+"</span></a></li></ul>";$(nPaging).append(sAppend);var els=$("a",nPaging),nPrevious=els[0],nNext=els[1];/* ID the first elements only */
oSettings.aanFeatures.p||(nPaging.id=oSettings.sTableId+"_paginate",nPrevious.id=oSettings.sTableId+"_previous",nNext.id=oSettings.sTableId+"_next",nPrevious.setAttribute("aria-controls",oSettings.sTableId),nNext.setAttribute("aria-controls",oSettings.sTableId));var fnClickHandler=function(e){e.preventDefault(),oSettings.oApi._fnPageChange(oSettings,e.data.action)&&fnCallbackDraw(oSettings)};oSettings.oApi._fnBindAction(nPrevious,{action:"previous"},fnClickHandler),oSettings.oApi._fnBindAction(nNext,{action:"next"},fnClickHandler)},fnUpdate:function(oSettings,fnCallbackDraw){if(oSettings.aanFeatures.p){var iStartButton,iEndButton,iPageCount=$.fn.dataTableExt.oPagination.iFullNumbersShowPages,iPageCountHalf=Math.floor(iPageCount/2),iPages=Math.ceil(oSettings.fnRecordsDisplay()/oSettings._iDisplayLength),iCurrentPage=Math.ceil(oSettings._iDisplayStart/oSettings._iDisplayLength)+1,fnBind=function(j){oSettings.oApi._fnBindAction(this,{page:j+iStartButton-1},function(e){/* Use the information in the element to jump to the required page */
oSettings.oApi._fnPageChange(oSettings,e.data.page),fnCallbackDraw(oSettings),e.preventDefault()})};/* Pages calculation */
-1===oSettings._iDisplayLength?(iStartButton=1,iEndButton=1,iCurrentPage=1):iPageCount>iPages?(iStartButton=1,iEndButton=iPages):iPageCountHalf>=iCurrentPage?(iStartButton=1,iEndButton=iPageCount):iCurrentPage>=iPages-iPageCountHalf?(iStartButton=iPages-iPageCount+1,iEndButton=iPages):(iStartButton=iCurrentPage-Math.ceil(iPageCount/2)+1,iEndButton=iStartButton+iPageCount-1);for(var oClasses=oSettings.oClasses,activeClass="active "+oClasses.sPageButtonActive,disabledClass="disabled "+oClasses.sPageButtonStaticDisabled,sList="",i=iStartButton;iEndButton>=i;i++)sList+=iCurrentPage!==i?'<li><a href="javascript:;" class="'+oClasses.sPageButton+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oSettings.fnFormatNumber(i)+"</a></li>":'<li class="'+activeClass+'"><a href="javascript:;" class="'+oClasses.sPageButton+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oSettings.fnFormatNumber(i)+"</a></li>";for(var an=oSettings.aanFeatures.p,i=0;i<an.length;i++)an[i].hasChildNodes()&&(/* Update the permanent button's classes */
1==iCurrentPage?$("li:eq(0)",an[i]).addClass(disabledClass):$("li:eq(0)",an[i]).removeClass(disabledClass),0===iPages||iCurrentPage===iPages||-1===oSettings._iDisplayLength?$("li:eq(-1)",an[i]).addClass(disabledClass):$("li:eq(-1)",an[i]).removeClass(disabledClass),/* Build up the dynamic list first - html and listeners */
$("li:gt(0)",an[i]).filter(":not(li:eq(-1))").remove(),$(sList).clone().insertBefore($("li:eq(-1)",an[i])).each(fnBind))}}},bootstrap_full_numbers:{fnInit:function(oSettings,nPaging,fnCallbackDraw){var oLang=oSettings.oLanguage.oPaginate,oClasses=oSettings.oClasses,disabledClass="disabled "+oClasses.sPageButtonStaticDisabled,sPageButtonText=oLang.sShowPagingText?"":"text-hide",sPageButton=oLang.sShowPagingText?oClasses.sPageButton:oClasses.sPageButton+" no-text",sAppend='<ul class="pagination"><li class="first '+disabledClass+'"><a href="javascript:;" class="'+sPageButton+" "+oClasses.sPageFirst+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+sPageButtonText+'">'+oLang.sFirst+'</span></a></li><li class="previous '+disabledClass+'"><a href="javascript:;" class="'+sPageButton+" "+oClasses.sPagePrevious+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+sPageButtonText+'">'+oLang.sPrevious+'</span></a></li><li class="next '+disabledClass+'"><a href="javascript:;" class="'+sPageButton+" "+oClasses.sPageNext+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+sPageButtonText+'">'+oLang.sNext+'</span></a></li><li class="last '+disabledClass+'"><a href="javascript:;" class="'+sPageButton+" "+oClasses.sPageLast+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+sPageButtonText+'">'+oLang.sLast+"</span></a></li></ul>";$(nPaging).append(sAppend);var els=$("a",nPaging),nFirst=els[0],nPrevious=els[1],nNext=els[2],nLast=els[3];/* ID the first elements only */
oSettings.aanFeatures.p||(nPaging.id=oSettings.sTableId+"_paginate",nFirst.id=oSettings.sTableId+"_first",nPrevious.id=oSettings.sTableId+"_previous",nNext.id=oSettings.sTableId+"_next",nLast.id=oSettings.sTableId+"_last",nFirst.setAttribute("aria-controls",oSettings.sTableId),nPrevious.setAttribute("aria-controls",oSettings.sTableId),nNext.setAttribute("aria-controls",oSettings.sTableId),nLast.setAttribute("aria-controls",oSettings.sTableId));var fnClickHandler=function(e){e.preventDefault(),oSettings.oApi._fnPageChange(oSettings,e.data.action)&&fnCallbackDraw(oSettings)};oSettings.oApi._fnBindAction(nFirst,{action:"first"},fnClickHandler),oSettings.oApi._fnBindAction(nPrevious,{action:"previous"},fnClickHandler),oSettings.oApi._fnBindAction(nNext,{action:"next"},fnClickHandler),oSettings.oApi._fnBindAction(nLast,{action:"last"},fnClickHandler)},fnUpdate:function(oSettings,fnCallbackDraw){if(oSettings.aanFeatures.p){var iStartButton,iEndButton,iPageCount=$.fn.dataTableExt.oPagination.iFullNumbersShowPages,iPageCountHalf=Math.floor(iPageCount/2),iPages=Math.ceil(oSettings.fnRecordsDisplay()/oSettings._iDisplayLength),iCurrentPage=Math.ceil(oSettings._iDisplayStart/oSettings._iDisplayLength)+1,fnBind=function(j){oSettings.oApi._fnBindAction(this,{page:j+iStartButton-1},function(e){/* Use the information in the element to jump to the required page */
oSettings.oApi._fnPageChange(oSettings,e.data.page),fnCallbackDraw(oSettings),e.preventDefault()})};/* Pages calculation */
-1===oSettings._iDisplayLength?(iStartButton=1,iEndButton=1,iCurrentPage=1):iPageCount>iPages?(iStartButton=1,iEndButton=iPages):iPageCountHalf>=iCurrentPage?(iStartButton=1,iEndButton=iPageCount):iCurrentPage>=iPages-iPageCountHalf?(iStartButton=iPages-iPageCount+1,iEndButton=iPages):(iStartButton=iCurrentPage-Math.ceil(iPageCount/2)+1,iEndButton=iStartButton+iPageCount-1);for(var oClasses=oSettings.oClasses,activeClass="active "+oClasses.sPageButtonActive,disabledClass="disabled "+oClasses.sPageButtonStaticDisabled,sList="",i=iStartButton;iEndButton>=i;i++)sList+=iCurrentPage!==i?'<li><a href="javascript:;" class="'+oClasses.sPageButton+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oSettings.fnFormatNumber(i)+"</a></li>":'<li class="'+activeClass+'"><a href="javascript:;" class="'+oClasses.sPageButton+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oSettings.fnFormatNumber(i)+"</a></li>";for(var an=oSettings.aanFeatures.p,i=0;i<an.length;i++)an[i].hasChildNodes()&&(/* Update the permanent button's classes */
1==iCurrentPage?($("li:eq(0)",an[i]).addClass(disabledClass),$("li:eq(1)",an[i]).addClass(disabledClass)):($("li:eq(0)",an[i]).removeClass(disabledClass),$("li:eq(1)",an[i]).removeClass(disabledClass)),0===iPages||iCurrentPage===iPages||-1===oSettings._iDisplayLength?($("li:eq(-1)",an[i]).addClass(disabledClass),$("li:eq(-2)",an[i]).addClass(disabledClass)):($("li:eq(-1)",an[i]).removeClass(disabledClass),$("li:eq(-2)",an[i]).removeClass(disabledClass)),/* Build up the dynamic list first - html and listeners */
$("li:gt(1)",an[i]).filter(":not(li:eq(-2))").filter(":not(li:eq(-1))").remove(),$(sList).clone().insertBefore($("li:eq(-2)",an[i])).each(fnBind))}}}}),/*
 * TableTools Bootstrap compatibility
 * Required TableTools 2.1+
 */
$.fn.DataTable.TableTools&&(
// Set the classes that TableTools uses to something suitable for Bootstrap
$.extend(!0,$.fn.DataTable.TableTools.classes,{container:"DTTT btn-group",buttons:{normal:"btn btn-default",disabled:"disabled"},collection:{container:"DTTT_dropdown dropdown-menu",buttons:{normal:"",disabled:"disabled"}},print:{info:"DTTT_print_info"},select:{row:"active"}}),
// Have the collection use a bootstrap compatible dropdown
$.extend(!0,$.fn.DataTable.TableTools.DEFAULTS.oTags,{collection:{container:"ul",button:"li",liner:"a"}})),angular.module("WebCoreModule").filter("WcPrice",["_",function(_){
// Helper Functions
function detectFilterType(min,max){/*
			Possible return values:
				range, min, max, invalid
		*/
var filterType="";return filterType=!min&&0!==min||!max&&0!==max?min&&null===max?"min":max&&null===min?"max":"invalid":"range"}function filterMax(items,max,propertyName){return propertyName?_.filter(items,function(num){return num[propertyName]<=max?!0:void 0}):_.filter(items,function(num){return max>=num?!0:void 0})}function filterMin(items,min,propertyName){return propertyName?_.filter(items,function(num){return num[propertyName]>=min?!0:void 0}):_.filter(items,function(num){return num>=min?!0:void 0})}function filterRange(items,min,max,propertyName){return propertyName?_.filter(items,function(num){return num[propertyName]>=min&&num[propertyName]<=max?!0:void 0}):_.filter(items,function(num){return num>=min&&max>=num?!0:void 0})}/*
		item: array of items to filter
		min: null or number
		max: null of number
		propertyName: if specified > assume array of objects : let function know where to find price in object. otherwise assume items are an array of simple values
		at least min or max is required - if both are present, calculate range
		example usage : var filteredArray = $filter('WcPrice')(originalArray, null, 500, 'price');
	*/
return function(items,min,max,propertyName){var newItems=[];
// Error Checking
(void 0===min||isNaN(min))&&(min=null),(void 0===max||isNaN(max))&&(max=null);
// Detect Filter Type
var filterType=detectFilterType(min,max);switch(filterType){case"range":newItems=filterRange(items,min,max,propertyName);break;case"min":newItems=filterMin(items,min,propertyName);break;case"max":newItems=filterMax(items,max,propertyName);break;case"invalid":newItems=items}return newItems}}]),/**
 * @ngdoc overview
 * @name WcResponsiveTableModule
 * @description
 * WcResponsiveTableModule is a collection of internally developed components and extensions which brings responsive behaviour
 * for jquery datatable, this module is also responsible for some features like sorting and filtering of datatable.
 */
angular.module("WcResponsiveTableModule",[]),angular.module("WcResponsiveTableModule").directive("wcResponsiveTable",["$compile","_","$timeout","$swipe",function($compile,_,$timeout,$swipe){return{scope:{data:"&",rowKey:"@",
//bind between our ngModel and our interal selectedRows
//selectedRows: '=ngModel',
ngModel:"=",resultsPerPage:"=",paginationControlsPlacement:"@",responsiveView:"@",columnData:"=",selectResultsPerPage:"="},require:["?ngModel"],controller:["_","$scope","$element","$attrs","WcTableScopeService","WcTableCollectionService","WcTablePaginationService",function(_,$scope,$element,$attrs,WcTableScopeService,WcTableCollectionService,WcTablePaginationService){var parentScope=$scope.$parent;""===$attrs.required&&($scope.required=!0),""===$attrs.paginationEnabled&&($scope.paginationEnabled=!0),WcTableCollectionService.setInitialCollection($scope.data()),WcTableCollectionService.setRowKey($scope.rowKey),WcTableScopeService.setParentScope(parentScope),WcTableScopeService.setTableScope($scope),
//the table errors out if the ngModel binding is not defined in the view controller
$scope.ngModel||($scope.ngModel=[]),$scope.lastCollectionRendered=null,$scope.renderTable=function(resetToPageOne){
//var collectionEnd = WcTablePaginationService.getPaginationDefaults().pageEnd;
//var collectionStart = WcTablePaginationService.getPaginationDefaults().pageStart;
//var collectionToRender = WcTableCollectionService.getCollection().slice(collectionStart, collectionEnd);
//var collectionsAreEqual;
//
//if($scope.lastCollectionRendered === null) {
//	$scope.lastCollectionRendered = collectionToRender;
//	collectionsAreEqual = false;
//} else {
//	collectionsAreEqual = _.isEqual($scope.lastCollectionRendered, collectionToRender);
//}
//
//if(!collectionsAreEqual) {
$scope.$broadcast("table.pagination.update",resetToPageOne),$scope.$broadcast("table.render.start")},$scope.tableIsLoading=function(){$(".wc-table-loading-indicator").show(),$(".wc-table-loading-cover").show()},$scope.tableIsFinishedLoading=function(){$(".wc-table-loading-indicator").hide(),$(".wc-table-loading-cover").hide()},$scope.tableRendered=function(){$(".wc-table-column-"+$scope.previousSortColumn).removeClass("wc-table-column-highlight"),$(".wc-table-column-"+$scope.activeSortColumn).addClass("wc-table-column-highlight"),$timeout(function(){parentScope.$broadcast("table.render.complete"),
//$scope.$digest();
$scope.tableIsFinishedLoading()},0)},$scope.toggleFilterVisibility=function(){$("div[wc-responsive-table] thead input[wc-column-filter], div[wc-responsive-table] thead select[wc-column-filter]").toggle();var currentText=$("div[wc-responsive-table] .filter-visibility-toggle span:first-child").text();currentText.indexOf("Show")>-1?(currentText=currentText.replace("Show","Hide"),$(".wc-table thead > tr > th").css("vertical-align","top")):(currentText=currentText.replace("Hide","Show"),$(".wc-table thead > tr > th").css("vertical-align","bottom")),$("div[wc-responsive-table] .filter-visibility-toggle span:first-child").text(currentText)};
//should match index for the first column of data
var ratchetIndex=2;$scope.ratchetCols=function(direction){
//only ratchet at mobile or tablet sizes
window.innerWidth<1200&&($scope.$broadcast("ng-swipe"),"left"==direction?($(".wc-table.table-ratchet .wc-table-column-"+ratchetIndex).hide(),ratchetIndex<$scope.numberOfCols&&ratchetIndex++):"right"==direction&&($(".wc-table.table-ratchet .wc-table-column-"+(ratchetIndex-1)).show(),ratchetIndex>2&&ratchetIndex--))},$scope.$on("ng-swipe",function(event,args){$scope.animating||($scope.animating=!0,
// pulse effect animation
$(".wc-table.table-ratchet table").animate({opacity:.7},150,function(){$(".wc-table.table-ratchet table").animate({opacity:1},200,function(){})}),$scope.animating=!1)}),$scope.columnsToHide=[],
// ==========
// Pagination
// ==========
($scope.paginationEnabled||$scope.resultsPerPage||$scope.numberOfPageControls||$scope.selectResultsPerPage||$scope.responsiveBreakpoints||$scope.paginationControlsPlacement)&&(WcTablePaginationService.setPaginationState(!0),WcTablePaginationService.setPaginationDefaults({numberOfPageControls:$scope.numberOfPageControls,responsiveBreakpoints:$scope.responsiveBreakpoints,selectResultsPerPage:$scope.selectResultsPerPage,resultsPerPage:$scope.resultsPerPage,paginationControlsPlacement:$scope.paginationControlsPlacement}))}],link:function(scope,elem,attrs,ctrl){
// jshint unused:true
var table=elem[0].children[0];"TABLE"!==table.tagName&&(console.error("Table tag <table> must come right after <wc-responsive-table>"),console.error("Directive found "+table[0].tagName+" instead")),elem.addClass("wc-table");var dataRow=$(table).find("tbody tr"),headerRow=$(table).find("thead tr")[0];scope.numberOfCols=headerRow.children.length;for(var i=0;i<headerRow.children.length;i++)scope.columnsToHide[i]=!1,$(headerRow.children[i]).addClass("wc-table-column-"+i);for(i=0;i<dataRow.children().length;i++){var item=$(dataRow.children()[i]);
//.attr('column-index', i);
if(item.addClass("wc-table-column-"+i),"list"==scope.responsiveView){var columnHeading=$(headerRow).find("th")[i],columnHeadingText=$(columnHeading).clone().children().remove().end().text();item.attr("data-title",columnHeadingText)}}if(scope.paginationEnabled&&elem.prepend($compile("<wc-table-pagination>")(scope)),"scroll"==scope.responsiveView)elem.addClass("table-responsive");else if("ratchet"==scope.responsiveView){elem.addClass("table-ratchet");
//$(table).attr('ng-swipe-left', 'ratchetCols("swipeLeft")');
//$(table).attr('ng-swipe-right', 'ratchetCols("swipeRight")');
// The maximum vertical delta for a swipe should be less than 75px.
//start block of modified code coming from angular-touch library.
var startCoords,valid,MAX_VERTICAL_DISTANCE=75,MAX_VERTICAL_RATIO=.3,MIN_HORIZONTAL_DISTANCE=30,directionOfSwipe=function(coords){
// Check that it's within the coordinates.
// Absolute vertical distance must be within tolerances.
// Horizontal distance, we take the current X - the starting X.
// This is negative for leftward swipes and positive for rightward swipes.
// After multiplying by the direction (-1 for left, +1 for right), legal swipes
// (ie. same direction as the directive wants) will have a positive delta and
// illegal ones a negative delta.
// Therefore this delta must be positive, and larger than the minimum.
if(!startCoords)return!1;var deltaY=Math.abs(coords.y-startCoords.y),deltaX=coords.x-startCoords.x;// Short circuit for already-invalidated swipes.
return valid&&MAX_VERTICAL_DISTANCE>deltaY&&0!=deltaX&&Math.abs(deltaX)>MIN_HORIZONTAL_DISTANCE&&deltaY/Math.abs(deltaX)<MAX_VERTICAL_RATIO?deltaX>0?"right":"left":!1};$swipe.bind($(table),{start:function(coords){startCoords=coords,valid=!0},cancel:function(){valid=!1},end:function(coords){var direction=directionOfSwipe(coords);direction&&scope.ratchetCols(direction)}})}else if("column-toggle"==scope.responsiveView){elem.addClass("column-toggle");
//add controls to allow the user to hide columns
var columnToggle='<span class="dropdown column-toggle"><span name="columnToggleDropdown" data-toggle="dropdown" id="columnToggleDropdown"><span>Hide Columns</span><span class="glyphicon glyphicon-minus-sign"></span></span><ul class="dropdown-menu" role="menu" aria-labelledby="columnToggleDropdown">';$(headerRow).children().each(function(index,item){index>1&&(columnToggle+='<li role="menuitem" class="show-later"><label for="col'+index+'"><input id="col'+index+'" type="checkbox" ng-model="columnsToHide['+index+']"/>'+item.firstChild.data+"</label></li>")}),columnToggle+="</ul></span>",scope.$watchCollection(function(){return scope.columnsToHide},function(newValue,oldValue){if(newValue!==oldValue)for(var i=0;i<newValue.length;i++)newValue[i]?$(".wc-table.column-toggle .wc-table-column-"+i).hide():$(".wc-table.column-toggle .wc-table-column-"+i).show()}),$(table).before($compile(columnToggle)(scope))}else"list"==scope.responsiveView?(elem.addClass("table-mobile-stack"),$(".filter-visibility-toggle").hide()):"drop"==scope.responsiveView;if(elem.find("thead input[wc-column-filter], thead select[wc-column-filter]").length){var filterToggle='<div class="filter-visibility-toggle" ng-click="toggleFilterVisibility()"><span>Show Filters</span><span class="glyphicon glyphicon-filter"></span></div>';$(table).before($compile(filterToggle)(scope)),$(table).before('<div class="active-filters"></div>')}var loadingElement='<div class="wc-table-loading-cover"><div></div></div><div class="wc-table-loading-indicator"><span class="glyphicon glyphicon-refresh"></span><span>Loading...</span></div>';elem.append(loadingElement);var setMatchingHeights=function(selector){$(selector).each(function(index,item){$(item).css("height",$(item).closest("tr").css("height"))})},columnResizeHandler=function(){setMatchingHeights(".wc-table-column-0"),setMatchingHeights(".wc-table-column-1")};if("scroll"==scope.responsiveView){$(window).on("resize",_.debounce(columnResizeHandler,250)),scope.$on("table.render.complete",_.debounce(columnResizeHandler,10));var scrollHandler=function(event){$(".table-responsive .wc-table-column-0").each(function(index,item){$(item).css("left",event.currentTarget.scrollLeft+"px")}),$(".table-responsive .wc-table-column-1").each(function(index,item){$(item).css("left",event.currentTarget.scrollLeft+100+"px")}),$("div[wc-responsive-table].table-responsive .filter-visibility-toggle").each(function(index,item){$(item).css("left",event.currentTarget.scrollLeft+15+"px")})};elem.scroll(scrollHandler),elem.on("touchmove",scrollHandler)}else"ratchet"==scope.responsiveView||"list"==scope.responsiveView||"drop"==scope.responsiveView;ctrl[0]&&(ctrl[0].$name="wcResponsiveTable",
//convert $viewValue to $modelValue
//$viewValue is passed in, modify it and return what will be applied to $modelValue
ctrl[0].$parsers.push(function(viewValue){
//add validation here for required fields
return scope.required&&(!viewValue||angular.isArray(viewValue)&&0==viewValue.length?ctrl[0].$setValidity("tableRequired",!1):ctrl[0].$setValidity("tableRequired",!0)),viewValue}),
//convert $modelValue to $viewValue
//$modelValue is passed in, modify it and return what will be applied to $viewValue
ctrl[0].$formatters.push(function(modelValue){
//add validation here for required fields
return scope.required&&(!modelValue||angular.isArray(modelValue)&&0==modelValue.length?ctrl[0].$setValidity("tableRequired",!1):ctrl[0].$setValidity("tableRequired",!0)),modelValue}),
//take values from the model and apply them to the view controls
//ctrl[0].$render = function() {
//	console.log('from render: ', ctrl[0].$viewValue);
//};
//function to call when $viewValue should be updated with a new value after a user interaction
scope.applyModel=function(value){ctrl[0].$setViewValue(value)},
//register this table with the form obj
ctrl[0].$$parentForm.$addControl(ctrl[0])),
//$compile(headerRow)(scope);
scope.dataRowChildren=dataRow.children().clone(),dataRow.children().remove(),dataRow.attr("wc-row-repeat",""),$compile(dataRow)(scope)}}}]),angular.module("WcResponsiveTableModule").directive("wcRowRepeat",["$compile",function($compile){return{controller:["WcTableScopeService","WcTableCollectionService","WcTablePaginationService",function(WcTableScopeService,WcTableCollectionService,WcTablePaginationService){this.collection=WcTableCollectionService.getCollection,this.tableScope=WcTableScopeService.getTableScope,this.rowKey=WcTableCollectionService.getRowKey(),this.pagination=WcTablePaginationService.getPaginationDefaults}],link:function(scope,element,attr,ctrl){function insertRows(pageStart,pageEnd){var block,childScope,index,elementsLength=elements.length,ngModel=ctrl.tableScope().ngModel,collection=ctrl.collection();if(elementsLength>0){for(index=0;elementsLength>index;index++)elements[index].el.remove(),elements[index].scope.$destroy();elements=[]}for(
//TODO make setCollection update pagination instead
collection.length<pageEnd&&(pageEnd=collection.length),index=pageStart;pageEnd>index;index++){if(childScope=scope.$new(!1,ctrl.tableScope()),childScope.row=collection[index],childScope.rowKey=childScope.row[ctrl.rowKey],childScope.index=index,ngModel.length>0){var alreadySelected=ngModel.reduce(function(prev,next){return next===childScope.rowKey?next:prev},null);(alreadySelected||0===alreadySelected)&&(childScope.isSelected=!0)}var newRow=$("<tr></tr>");newRow.append(scope.dataRowChildren.clone()),block={},block.el=newRow,block.scope=childScope,elements.push(block),parentElement.append(newRow),$compile(newRow)(childScope)}}
// jshint unused:true
var elements=[],parentElement=element.parent();element.remove(),scope.$on("table.render.start",function(){insertRows(ctrl.pagination().pageStart,ctrl.pagination().pageEnd),ctrl.tableScope().tableRendered()})}}}]),angular.module("WcResponsiveTableModule").directive("wcRowSelectCheckbox",["$filter",function($filter){return{restrict:"E",template:'<input type="checkbox" ng-change="selectRow()" class="wc-checkbox-column" ng-model="isChecked">',scope:{},controller:["$scope","$element","WcTableScopeService",function($scope,$element,WcTableScopeService){$scope.selectRow=function(){var tableScope=WcTableScopeService.getTableScope(),objId=$scope.$parent.rowKey,ngModel=tableScope.ngModel,isInNgModel=0!==$filter("filter")(ngModel,objId,!0).length;isInNgModel&&!$scope.isChecked?tableScope.ngModel=$filter("filter")(ngModel,function(value){return value!==objId},!0):isInNgModel||tableScope.ngModel.push(objId),tableScope.applyModel(tableScope.ngModel)},$scope.$on("table.render.complete",function(){$scope.$parent.isSelected&&($scope.isChecked=!0)}),$scope.$on("table.select.checkbox.all",function(){$scope.isChecked=!0,$scope.selectRow()}),$scope.$on("table.select.checkbox.none",function(){$scope.isChecked=!1,$scope.selectRow()})}],link:function(scope,elem){var highlightRow=function(shouldHighlight){var row=elem.parent().parent();shouldHighlight?$(row).addClass("wc-highlight-row"):$(row).removeClass("wc-highlight-row");var tableCells=row.children();$(tableCells).each(function(index,cell){
// jshint unused:true
shouldHighlight?$(cell).addClass("wc-highlight-row"):$(cell).removeClass("wc-highlight-row")})};scope.$watch("isChecked",function(boolean){highlightRow(boolean)})}}}]),angular.module("WcResponsiveTableModule").directive("wcRowSelectRadio",function(){return{restrict:"E",template:'<input type="radio" name="table" class="wc-radio-column" ng-click="selectRow()">',scope:{},controller:["$scope","WcTableScopeService",function($scope,WcTableScopeService){$scope.tableScope=WcTableScopeService.getTableScope(),$scope.rowKey=$scope.$parent.rowKey,$scope.selectRow=function(){var tableScope=WcTableScopeService.getTableScope(),objId=$scope.$parent.rowKey;tableScope.ngModel=[objId],tableScope.applyModel(tableScope.ngModel)},$scope.$on("table.render.complete",function(){$scope.$parent.isSelected&&($scope.highlightRow(!0),$scope.selectRow())})}],link:function(scope,elem){scope.highlightRow=function(shouldHighlight){var row=elem.parent().parent();shouldHighlight?$(row).addClass("wc-highlight-row"):$(row).removeClass("wc-highlight-row");var tableCells=row.children();$(tableCells).each(function(index,cell){
//modified this loop to make it also maintain the checked status of the table radios
var rowRadio=$(cell).find(".wc-radio-column");shouldHighlight?($(cell).addClass("wc-highlight-row"),rowRadio&&rowRadio.prop("checked",!0)):($(cell).removeClass("wc-highlight-row"),rowRadio&&rowRadio.prop("checked",!1))})},scope.$watch("tableScope.ngModel",function(newRow){if(scope.$parent.$parent.ngModel){var highlight;highlight=newRow[0]===scope.rowKey&&newRow.length>0,scope.highlightRow(highlight)}})}}}),angular.module("WcResponsiveTableModule").directive("wcRowSelectAll",function(){return{restrict:"A",scope:{},controller:["$scope","WcTableScopeService",function($scope,WcTableScopeService){$scope.viewScope=WcTableScopeService.getParentScope(),$scope.selectAll=function(){$scope.viewScope.$broadcast("table.select.checkbox.all"),$scope.viewScope.$broadcast("table.select.button.all"),$scope.$apply()}}],link:function(scope,elem){elem.on("click",function(){scope.selectAll()})}}}),angular.module("WcResponsiveTableModule").directive("wcRowSelectNone",function(){return{restrict:"A",scope:{},controller:["$scope","WcTableScopeService",function($scope,WcTableScopeService){var viewScope=WcTableScopeService.getParentScope();$scope.selectNone=function(){viewScope.$broadcast("table.select.checkbox.none"),viewScope.$broadcast("table.select.button.none"),$scope.$apply()}}],link:function(scope,elem){elem.on("click",function(){scope.selectNone()})}}}),angular.module("WcResponsiveTableModule").directive("wcTableSelectionInfo",function(){return{restrict:"E",scope:{},template:"<span>{{numberOfSelectedRows}} rows currently selected.</span>",controller:["$scope","WcTableScopeService",function($scope,WcTableScopeService){var tableScope=WcTableScopeService.getTableScope();$scope.numberOfSelectedRows=0,tableScope.$watch(function(){return tableScope.ngModel.length},function(newVal,oldVal){newVal!=oldVal&&($scope.numberOfSelectedRows=newVal)})}]}}),angular.module("WcResponsiveTableModule").directive("wcRowActionSingle",function(){return{restrict:"A",scope:{wcRowActionSingle:"@"},controller:["$scope","WcTableScopeService",function($scope,WcTableScopeService){$scope.singleAction=function(){var rowScope=$scope.$parent,viewScope=WcTableScopeService.getParentScope(),data=[].concat(rowScope.rowKey);console.log("rowActionSingle: rowScope:",rowScope),viewScope.$broadcast($scope.wcRowActionSingle,data)}}],link:function(scope,elem){elem.on("click",function(){scope.singleAction()})}}}),angular.module("WcResponsiveTableModule").directive("wcRowSelectHeaderCheckbox",function(){return{restrict:"E",template:'<input type="checkbox" ng-click="selectAllRows()" ng-model="isChecked" class="wc-header-checkbox">',scope:{wcRowSelectHeaderCheckbox:"@"},controller:["$scope","$timeout","WcTableScopeService",function($scope,$timeout,WcTableScopeService){var tableScope=WcTableScopeService.getTableScope(),checkIfAllChecked=function(){for(var allCheckboxes=angular.element('tbody input[type="checkbox"]'),i=0;i<allCheckboxes.length;i++)if(!angular.element(allCheckboxes[i]).is(":checked")){$scope.isChecked=!1;break}};$scope.$on("table.render.complete",function(){$timeout(function(){$scope.isChecked=!0,checkIfAllChecked()})}),$scope.$watch(function(){return tableScope.ngModel},function(){checkIfAllChecked()}),$scope.selectAllRows=function(){var event=$scope.isChecked?"table.select.checkbox.all":"table.select.checkbox.none";tableScope.$broadcast(event)},$scope.$on("table.select.button.all",function(){$scope.isChecked=!0}),$scope.$on("table.select.button.none",function(){$scope.isChecked=!1})}]}}),angular.module("WcResponsiveTableModule").directive("wcRowActionMultiple",function(){return{restrict:"A",scope:{wcRowActionMultiple:"@"},controller:["$scope","WcTableScopeService",function($scope,WcTableScopeService){$scope.multipleAction=function(){var ngModel=WcTableScopeService.getTableScope().ngModel,viewScope=WcTableScopeService.getParentScope();ngModel.length&&viewScope.$broadcast($scope.wcRowActionMultiple,[].concat(ngModel))}}],link:function(scope,elem){elem.on("click",function(){scope.multipleAction()})}}}),/**
		 * @ngdoc directive
		 * @name WcResponsiveTableModule.directive:wcTablePagination
		 * @description
		 * The wcTablePagination directive is responsible for pagination operation in datatable
		 */
angular.module("WcResponsiveTableModule").directive("wcTablePagination",["$compile",function($compile){return{scope:{},controller:["$scope","$window","_","WcTableScopeService","WcTablePaginationService","WcTableCollectionService",function($scope,$window,_,WcTableScopeService,WcTablePaginationService,WcTableCollectionService){var pagination,tableScope=WcTableScopeService.getTableScope();$scope.pagination=WcTablePaginationService.getPaginationDefaults(),pagination=$scope.pagination,$scope.$on("table.pagination.update",function(event,resetCurrentPage){resetCurrentPage&&(pagination.currentPage=1),pagination.totalItems=WcTableCollectionService.getCollectionLength(),pagination.totalPages=Math.ceil(pagination.totalItems/pagination.resultsPerPage),$scope.updatePaginationControls(pagination.currentPage),$scope.createPaginationControlNumbers()}),pagination.boundaryLinks=!0,pagination.currentBreakpoint="",pagination.currentPage=1,pagination.paginationPageControls=[],pagination.totalItems=WcTableCollectionService.getCollectionLength(),pagination.totalPages=Math.ceil(pagination.totalItems/pagination.resultsPerPage),$scope.createPaginationControlNumbers=function(){for(var array=[],paginationOffset=Math.floor(pagination.numberOfPageControls/2),index=0;index<pagination.numberOfPageControls;index++)pagination.currentPage-paginationOffset>0&&pagination.currentPage-paginationOffset<=pagination.totalPages&&array.push(pagination.currentPage-paginationOffset),paginationOffset--;if(array.length<pagination.numberOfPageControls){var pageNumberToAdd,i,checkValue=Math.floor(pagination.currentPage-pagination.numberOfPageControls/2),numberOfPagesNeeded=Math.abs(array.length-pagination.numberOfPageControls);if(0>=checkValue){var lastPageAdded=array[array.length-1];for(i=1;numberOfPagesNeeded>=i;i++)pageNumberToAdd=lastPageAdded+i,pagination.totalPages>=pageNumberToAdd&&array.push(pageNumberToAdd)}else{var firstPageAdded=array[0];for(i=1;numberOfPagesNeeded>=i;i++)pageNumberToAdd=firstPageAdded-i,array.unshift(pageNumberToAdd)}}pagination.paginationPageControls=array},$scope.changeResultsPerPage=function(){if("All"===pagination.resultsPerPage)pagination.resultsPerPage=pagination.totalItems,pagination.pageStart=0,pagination.pageEnd=pagination.totalItems,pagination.totalPages=1,$scope.changePage(1);else{pagination.totalPages=Math.ceil(pagination.totalItems/pagination.resultsPerPage);var newPage=Math.ceil(pagination.pageStart/pagination.resultsPerPage);$scope.changePage(newPage?newPage:1)}},$scope.updatePaginationControls=function(pageNumber){pagination.currentPage=pageNumber,pagination.pageStart=pageNumber*pagination.resultsPerPage-pagination.resultsPerPage;var newPageEnd=pagination.pageStart+pagination.resultsPerPage;newPageEnd>pagination.totalItems?pagination.pageEnd=pagination.totalItems:pagination.pageEnd=newPageEnd,WcTablePaginationService.setPaginationDefaults({pageStart:pagination.pageStart,pageEnd:pagination.pageEnd})},$scope.changePage=function(pageNumber){if(!(pageNumber>0&&pageNumber<=pagination.totalPages))throw isNaN(pageNumber)?"Invaild Page Number: "+pageNumber+". Must be a number, no other characters allowed":0>=pageNumber?"Invaild Page Number: "+pageNumber+". Must be greater than 0":pageNumber>pagination.totalPages?"Invaild Page Number: "+pageNumber+". Must be smaller than "+pagination.totalPages:"Invaild Page Number: "+pageNumber+". Not sure what you did, but it is invalid";$scope.updatePaginationControls(pageNumber),$scope.createPaginationControlNumbers(),tableScope.renderTable()},$scope.nextPage=function(){var nextPageNumber=pagination.currentPage;nextPageNumber+1<=pagination.totalPages&&$scope.changePage(++nextPageNumber)},$scope.previousPage=function(){var nextPageNumber=pagination.currentPage;nextPageNumber-1>0&&$scope.changePage(--nextPageNumber)},$scope.$watch(function(){return pagination.currentBreakpoint},function(newValue,oldValue){newValue!==oldValue&&("xs"===newValue?(pagination.numberOfPageControls=0,pagination.boundaryLinks=!1):"sm"===newValue?(pagination.numberOfPageControls=0,pagination.boundaryLinks=!1):"md"===newValue?(pagination.numberOfPageControls=0,pagination.boundaryLinks=!1):"lg"===newValue?(pagination.numberOfPageControls=3,pagination.boundaryLinks=!0):(pagination.numberOfPageControls=WcTablePaginationService.getPaginationDefaults().numberOfPageControls,pagination.boundaryLinks=!0),$scope.createPaginationControlNumbers())});var resizeHandler=function(){
//<=430 is default
window.innerWidth<=pagination.responsiveBreakpoints[0]&&"xs"!==pagination.currentBreakpoint?pagination.currentBreakpoint="xs":window.innerWidth>pagination.responsiveBreakpoints[0]&&window.innerWidth<=pagination.responsiveBreakpoints[1]&&"sm"!==pagination.currentBreakpoint?pagination.currentBreakpoint="sm":window.innerWidth>pagination.responsiveBreakpoints[1]&&window.innerWidth<=pagination.responsiveBreakpoints[2]&&"md"!==pagination.currentBreakpoint?pagination.currentBreakpoint="md":window.innerWidth>pagination.responsiveBreakpoints[2]&&window.innerWidth<=pagination.responsiveBreakpoints[3]&&"lg"!==pagination.currentBreakpoint?pagination.currentBreakpoint="lg":window.innerWidth>pagination.responsiveBreakpoints[3]&&"xl"!==pagination.currentBreakpoint&&(pagination.currentBreakpoint="xl"),$scope.$digest()};
//debounce this handler to avoid rapid-fire resize events
angular.element($window).bind("resize",_.debounce(resizeHandler,300)),
//finally, call the resizeHandler once to initialize our breakpoint var
setTimeout(resizeHandler,0)}],link:function(scope){var resultsPerPageTemplate=['<div class="col-xs-3 result-page-count">',"<label>Results Per Page: ",'<select class="form-control form-inline input-sm pagination-results-per-page" ng-options="result for result in pagination.selectResultsPerPage"','ng-model="pagination.resultsPerPage" ng-change="changeResultsPerPage()">',"</select></label>","</div>"].join(""),paginationLegendTemplate=['<div class="col-xs-4 text-right">','<p class="hidden-xs hidden-sm results-data">',"Displaying {{pagination.pageStart + 1}} - {{pagination.pageEnd}} of {{pagination.totalItems}}","</p>","</div>"].join(""),paginationControlsTemplate=['<div class="col-xs-5 pagination-control text-right">','<ul class="hidden-xs pagination pagination-sm">','<li ng-hide="!pagination.boundaryLinks" class="pagination-page"><button ng-click="changePage(1)">&#xe069</button></li>','<li class="pagination-page"><button class="previous" ng-click="previousPage()" ng-class="{disabled: pagination.currentPage == 1}">&#xe071</button></li>','<li class="pagination-page pagination-page-number" ng-class="{active: pagination.currentPage === number}" ng-repeat="number in pagination.paginationPageControls">','<button ng-click="changePage(number)">{{number}}</button>',"</li>",'<li class="pagination-page"><button class="next" ng-click="nextPage()" ng-class="{disabled: pagination.currentPage == pagination.totalPages}">&#xe075</button></li>','<li ng-hide="!pagination.boundaryLinks" class="pagination-page"><button ng-click="changePage(pagination.totalPages)">&#xe077</button></li>',"</ul>","<div>"].join(""),navigateToPageTemplate=['<div class="hidden-sm hidden-md hidden-lg hidden-xl text-center">','<ul class="pagination pagination-sm">','<li class="pagination-page" ng-class="{disabled: pagination.currentPage == 1}"><button class="previous" ng-click="previousPage()">&#xe071</button></li>',"<li>",'<input type="text" pattern="[0-9]*" ng-model="pagination.newInputPage" ng-change="changePage(pagination.newInputPage)" placeholder="Jump to Page" />',"</li>",'<li class="pagination-page" ng-class="{disabled: pagination.currentPage == pagination.totalPages}"><button class="next" ng-click="nextPage()">&#xe075</button></li>',"</ul>",'<p class="text-center">Page {{pagination.currentPage}} of {{pagination.totalPages}}</p>',"</div>"].join(""),action=$("div[wc-responsive-table]").attr("data-table-name"),actionDropdownTemplate=[];action&&(actionDropdownTemplate=['<div class="col-xs-12 hidden action-dropdown">','<div class="col-xs-4 pt-10"><strong>Row Actions :</strong></div>','<div class="col-xs-8">','<select class="form-control inline">',"<option>--Select--</option>","<option>Delete</option>","</select>",'<button class="btn ml-5 mt-neg-3 btn-primary" wc-row-action-multiple="delete-'+action+'">Submit</button>',"</div>","</div>"].join(""));var template=['<div class="col-xs-12">','<div class="row">',resultsPerPageTemplate,paginationLegendTemplate,paginationControlsTemplate,navigateToPageTemplate,"</div>","</div>",actionDropdownTemplate].join(""),controlsPlacement=scope.pagination.paginationControlsPlacement,wrapper=$("div[wc-responsive-table]");scope.createPaginationControlNumbers(),"top"!==controlsPlacement&&"both"!==controlsPlacement||wrapper.before($compile(template)(scope)),"bottom"!==controlsPlacement&&"both"!==controlsPlacement||wrapper.after($compile(template)(scope))}}}]),angular.module("WcResponsiveTableModule").directive("wcColumnSort",function(){return{restrict:"A",scope:{wcColumnSort:"@",wcColumnSortDefault:"@",specialChars:"@",columnIndex:"@"},controller:["$scope","$timeout","WcTableScopeService","WcTableCollectionService","WcTablePaginationService",function($scope,$timeout,WcTableScopeService,WcTableCollectionService,WcTablePaginationService){var specialChars=$scope.specialChars;$scope.tableScope=WcTableScopeService.getTableScope(),$scope.sortReverse=!1,$scope.timeout=$timeout,this.collectionLength=WcTableCollectionService.getCollectionLength(),this.resultsPerPage=WcTablePaginationService.getPaginationDefaults().resultsPerPage,$scope.sortCollection=function(){
//induce a delay to limit the FOUC
$scope.timeout(function(){function sortOn(arr,prop,reverse,specialChars){return reverse=reverse?1:-1,specialChars?arr.sort(function(a,b){return 1===reverse?WcTableScopeService.getNestedProperty(b,prop).localeCompare(WcTableScopeService.getNestedProperty(a,prop)):WcTableScopeService.getNestedProperty(a,prop).localeCompare(WcTableScopeService.getNestedProperty(b,prop))}):arr.sort(function(a,b){return WcTableScopeService.getNestedProperty(a,prop)<WcTableScopeService.getNestedProperty(b,prop)?1*reverse:WcTableScopeService.getNestedProperty(a,prop)>WcTableScopeService.getNestedProperty(b,prop)?-1*reverse:0})}var collection=WcTableCollectionService.getCollection();$scope.tableScope.previousSortColumn=$scope.tableScope.activeSortColumn,$scope.tableScope.activeSortColumn=$scope.columnIndex,WcTableCollectionService.setCollection(sortOn(collection,$scope.wcColumnSort,$scope.sortReverse,specialChars),!0),$scope.tableScope.$broadcast("table.sort.complete",$scope.wcColumnSort,$scope.sortReverse),$scope.sortReverse=!$scope.sortReverse},30)},$scope.wcColumnSortDefault&&("desc"==$scope.wcColumnSortDefault&&($scope.sortReverse=!0),$scope.sortCollection())}],
//jshint unused:true
link:function(scope,elem,attrs,ctrl){
//jshint unused:"strict"
elem.addClass("wc-table-column-sort-heading"),
//if(scope.$parent.ngModel) {
//include listener for when the sorted column changes
scope.tableScope.$on("table.sort.complete",function(event,column,reverse){var thSpan=elem.find("span.glyphicon:first-child"),columnClass=elem.attr("class").match(/wc-table-column-\d/g)[0];
//var columnSelector = '.wc-table-column-' + scope.columnIndex;
column===scope.wcColumnSort?(thSpan.toggleClass("glyphicon-sort",!1),reverse?(thSpan.toggleClass("glyphicon-sort-by-alphabet-alt",!0),thSpan.toggleClass("glyphicon-sort-by-alphabet",!1)):(thSpan.toggleClass("glyphicon-sort-by-alphabet",!0),thSpan.toggleClass("glyphicon-sort-by-alphabet-alt",!1)),$("."+columnClass).addClass("wc-table-column-highlight")):(thSpan.toggleClass("glyphicon-sort",!0),thSpan.toggleClass("glyphicon-sort-by-alphabet glyphicon-sort-by-alphabet-alt",!1),$("."+columnClass).removeClass("wc-table-column-highlight"),
//elem.removeClass('sorted');
scope.sortReverse=!1)}),scope.tableScope.$on("table.render.complete",function(event){var columnClass=elem.attr("class").match(/wc-table-column-\d/g)[0];elem.hasClass("wc-table-column-highlight")?$("td."+columnClass).addClass("wc-table-column-highlight"):$("td."+columnClass).removeClass("wc-table-column-highlight")}),elem.on("click",function(){var collectionLength=ctrl.collectionLength,showLoadingIndicator=!1;ctrl.resultsPerPage<=25?collectionLength>=1e5&&(showLoadingIndicator=!0):ctrl.resultsPerPage<=75?collectionLength>=1e4&&(showLoadingIndicator=!0):collectionLength>=1e3&&(showLoadingIndicator=!0),showLoadingIndicator&&scope.tableScope.tableIsLoading(),scope.sortCollection()}),
//glyphicon-sort-by-alphabet
//glyphicon-sort-by-alphabet-alt
elem[0].children.length?elem.find("input, select").before('<span class="glyphicon glyphicon-sort"></span>'):elem.append('<span class="glyphicon glyphicon-sort"></span>')}}}),angular.module("WcResponsiveTableModule").directive("wcColumnFilter",["$compile",function($compile){return{restrict:"A",scope:{wcColumnFilter:"@",wcColumnFilterDelay:"@"},controller:["$scope","WcTableScopeService","_","wcColumnFilterService","WcTableCollectionService","$timeout",function($scope,WcTableScopeService,_,wcColumnFilterService,WcTableCollectionService,$timeout){var tableScope=WcTableScopeService.getTableScope(),collection=WcTableCollectionService.getCollection();
//reassign our local collection var when an update has occurred.
//also rerun the filters
tableScope.$on("table.collection.update",angular.bind(this,function(){collection=WcTableCollectionService.getCollection(),$timeout(angular.bind(this,function(){this.filterColumn()}),0)})),
//$scope.$watch(function(){return WcTableCollectionService.getCollection()}, function(newVal){console.log(newVal.length)});
this.predicate=$scope.wcColumnFilter,this.wcColumnFilterService=wcColumnFilterService,this.collection=collection,$scope.wcColumnFilterDelay=$scope.wcColumnFilterDelay||0,$scope.isMultiSelect=!1,this.filterColumn=function(){
//TODO only handle one copy of the collection
var filterPairsArray=_.pairs(wcColumnFilterService.getColumnsToFilter());
//no filters, don't run the filter routines. instead reset with the collection
if(0==filterPairsArray.length)WcTableCollectionService.setCollection(collection,!1,!0);else{var filteredCollection=_.filter(collection,angular.bind(this,function(item){for(var match,i=0;i<filterPairsArray.length;i++)if(angular.isArray(filterPairsArray[i][1])){match=!1;for(var j=0;j<filterPairsArray[i][1].length;j++)if(WcTableScopeService.getNestedProperty(item,filterPairsArray[i][0]).toString().toLowerCase().indexOf(filterPairsArray[i][1][j].toLowerCase())>-1){match=!0;break}}else{if(!(WcTableScopeService.getNestedProperty(item,filterPairsArray[i][0]).toString().toLowerCase().indexOf(filterPairsArray[i][1].toLowerCase())>-1)){match=!1;break}match=!0}return match}));WcTableCollectionService.setCollection(filteredCollection,!1,!0)}},$scope.dismissFilter=function(id){var filterInput=$('input[wc-column-filter="'+id+'"], select[wc-column-filter="'+id+'"]');"SELECT"===filterInput.prop("tagName")?(filterInput.val(""),filterInput.trigger("change")):(filterInput.val(""),filterInput.trigger("keyup")),$(".active-filters ."+id.replace(".","-")).remove()}}],link:function(scope,element,attr,ctrl){var filterListener=function(){var elementVal=null==element.val()?"":element.val();ctrl.wcColumnFilterService.setColumnsToFilter(ctrl.predicate,elementVal),ctrl.filterColumn();var filterIconFinder=$(element[0].parentElement).find("span.glyphicon-filter"),htmlPredicate=ctrl.predicate.replace(".","-"),activeFilterButton=$(".active-filters ."+htmlPredicate);""!==elementVal?(filterIconFinder.length||element.before('<span class="glyphicon glyphicon-filter"></span>'),activeFilterButton.length?activeFilterButton.find("span:last-child").text(element.parent()[0].firstChild.data+": "+JSON.stringify(elementVal,null,1)):$(".active-filters").append($compile('<button class="'+htmlPredicate+'" ng-click="dismissFilter(\''+ctrl.predicate+'\')"><span class="glyphicon glyphicon-remove"></span><span>'+element.parent()[0].firstChild.data+": "+JSON.stringify(elementVal,null,1)+"</span></button>")(scope))):""==elementVal&&(filterIconFinder.remove(),activeFilterButton.remove())};
//if(scope.$parent.ngModel) {
if("SELECT"===element.prop("tagName")){scope.isMultiSelect=element.attr("multiple");var options=_.uniq(_.pluck(ctrl.collection,ctrl.predicate)).sort(),option=$("<option></option>");scope.isMultiSelect||(option.attr("value",""),option.text("Select an option"),element.append(option)),_.each(options,function(item){var option=$("<option></option>");option.attr("value",item),option.text(item),element.append(option)}),element.on("change",filterListener)}else element.keyup(_.debounce(filterListener,scope.wcColumnFilterDelay));
//prevent sort action from firing when a click happens in a filter box
element.on("click",function(evt){evt.stopPropagation()})}}}]),angular.module("WcResponsiveTableModule").service("WcTableScopeService",function(){var parentScope=null,tableScope=null;/**
			 * @ngdoc method
			 * @name getParentScope
			 * @methodOf WcResponsiveTableModule.service:WcTableScopeService
			 * @returns {string} This string holds parent scope value.
			 * @description
			 * The method is to get the parent scope value
			 */
this.getParentScope=function(){return parentScope},/**
			 * @ngdoc method
			 * @name getTableScope
			 * @methodOf WcResponsiveTableModule.service:WcTableScopeService
			 * @returns {string} This string holds table scope value.
			 * @description
			 * The method is to get the table scope value
			 */
this.getTableScope=function(){return tableScope},/**
			 * @ngdoc method
			 * @name setParentScope
			 * @methodOf WcResponsiveTableModule.service:WcTableScopeService
			 * @param {string} newParentScope This string value holds the new parent scope
			 * @description
			 * The method is to set the parent scope value
			 */
this.setParentScope=function(newParentScope){0===newParentScope.$id||newParentScope.$id?tableScope&&newParentScope.$id===tableScope.$id?(parentScope=null,console.error("WcTableScopeService: setTableScope(); parent scope and table scope can not be the same scope")):parentScope=newParentScope:(parentScope=null,console.error("WcTableScopeService: setTableScope(); You must pass in a valid Angular Scope"))},/**
			 * @ngdoc method
			 * @name setTableScope
			 * @methodOf WcResponsiveTableModule.service:WcTableScopeService
			 * @param {string} newTableScope This string value holds the new table scope
			 * @description
			 * The method is to set the table scope value
			 */
this.setTableScope=function(newTableScope){0===newTableScope.$id||newTableScope.$id?parentScope&&newTableScope.$id===parentScope.$id?(tableScope=null,console.error("WcTableScopeService: setTableScope(); parent scope and table scope can not be the same scope")):tableScope=newTableScope:(tableScope=null,console.error("WcTableScopeService: setTableScope(); You must pass in a valid Angular Scope"))},
//helper function for situations where we need to "go deep" into an object to find the correct property
this.getNestedProperty=function(obj,stringId){var propertyTreeArray=stringId.split(".");if(angular.isArray(propertyTreeArray)&&propertyTreeArray.length>1){for(var holder=obj[propertyTreeArray[0]],i=1;i<propertyTreeArray.length;i++)holder=holder[propertyTreeArray[i]];return holder}return obj[stringId]}}),angular.module("WcResponsiveTableModule").service("wcColumnFilterService",function(){var columnsToFilter={};/**
			 * @ngdoc method
			 * @name wcColumnFilterService.getColumnsToFilter
			 * @methodOf WcResponsiveTableModule.service:wcColumnFilterService
			 * @returns {string} This string holds the list of columns to be filtered
			 * @description
			 * The method returns the columns that needs to be filtered
			 */
this.getColumnsToFilter=function(){return columnsToFilter},/**
			 * @ngdoc method
			 * @name wcColumnFilterService.setColumnsToFilter
			 * @methodOf WcResponsiveTableModule.service:wcColumnFilterService
			 * @param {intiger} key This integer value holds the index of the array
			 * @param {string} value This string value holds the value of the array
			 * @description
			 * The method set the columns to the array
			 */
this.setColumnsToFilter=function(key,value){columnsToFilter[key]=value}}),angular.module("WcResponsiveTableModule").service("WcTableCollectionService",["WcTableScopeService",function(WcTableScopeService){var collection=[],rowKey="";/**
		 * @ngdoc method
		 * @name getCollection
		 * @methodOf WcResponsiveTableModule.service:WcTableCollectionService
		 * @returns {array} This array holds table collection values
		 * @description
		 * The method returns the table collection array.
		 */
this.getCollection=function(){return collection},/**
		 * @ngdoc method
		 * @name getCollectionLength
		 * @methodOf WcResponsiveTableModule.service:WcTableCollectionService
		 * @returns {intiger} This integer value holds length of the collection array
		 * @description
		 * The method returns the collection length
		 */
this.getCollectionLength=function(){return collection.length},/**
		 * @ngdoc method
		 * @name getRowKey
		 * @methodOf WcResponsiveTableModule.service:WcTableCollectionService
		 * @returns {intiger} This integer value holds the index of the array
		 * @description
		 * The method returns the index of the array
		 */
this.getRowKey=function(){return rowKey},/**
		 * @ngdoc method
		 * @name setCollection
		 * @methodOf WcResponsiveTableModule.service:WcTableCollectionService
		 * @param {array} newCollection This array holds the collection data
		 * @param {boolean} sorted This boolean value decides whether the collection is sorted or not
		 * @param {boolean} filtered This boolean value decides whether the collection is filtered or not
		 * @description
		 * The method set the collection to an array based on sorting and filtered value.
		 */
this.setCollection=function(newCollection,sorted,filtered){collection=newCollection,void 0===sorted&&void 0===filtered&&WcTableScopeService.getTableScope().$broadcast("table.collection.update"),WcTableScopeService.getTableScope().renderTable(sorted||filtered)},/**
		 * @ngdoc method
		 * @name setInitialCollection
		 * @methodOf WcResponsiveTableModule.service:WcTableCollectionService
		 * @param {array} initialCollection This array holds the collection data
		 * @description
		 * The method set the initial collection values to an array
		 */
this.setInitialCollection=function(initialCollection){collection=initialCollection},/**
		 * @ngdoc method
		 * @name setRowKey
		 * @methodOf WcResponsiveTableModule.service:WcTableCollectionService
		 * @param {intiger} newRowKey This integer value holds the new index of the array.
		 * @description
		 * The method set the new index to the current index value.
		 */
this.setRowKey=function(newRowKey){newRowKey?rowKey=newRowKey:(rowKey="id",collection.forEach(function(obj,index){obj[rowKey]=index}))}}]),angular.module("WcResponsiveTableModule").service("WcTablePaginationService",["WcTableCollectionService",function(WcTableCollectionService){var paginationEnabled,paginationDefaults={pageStart:0,pageEnd:10,resultsPerPage:10,numberOfPageControls:5,selectResultsPerPage:[10,25,50,100],responsiveBreakpoints:[430,500,600,900],paginationControlsPlacement:"both"};/**
		 * @ngdoc method
		 * @name getPaginationDefaults
		 * @methodOf WcResponsiveTableModule.service:WcTablePaginationService
		 * @returns {json} This json holds pagination default values
		 * @description
		 * This method is to get the pagination default values.
		 */
this.getPaginationDefaults=function(){return paginationEnabled?angular.copy(paginationDefaults):{pageStart:0,pageEnd:WcTableCollectionService.getCollectionLength()}},/**
		 * @ngdoc method
		 * @name isPaginationEnabled
		 * @methodOf WcResponsiveTableModule.service:WcTablePaginationService
		 * @returns {boolean} This boolean value returns a true or false.
		 * @description
		 * This method is to set the pagination option for datatable.
		 */
this.isPaginationEnabled=function(){return paginationEnabled},/**
		 * @ngdoc method
		 * @name setPaginationDefaults
		 * @methodOf WcResponsiveTableModule.service:WcTablePaginationService
		 * @param {json} newDefaults The json string holds the new default values for pagination
		 * @description
		 * This method is to set the pagination default values.
		 */
this.setPaginationDefaults=function(newDefaults){for(var property in newDefaults)0===paginationDefaults[property]||paginationDefaults[property]?(newDefaults[property]||"number"==typeof newDefaults[property]&&newDefaults[property]>-1)&&(paginationDefaults[property]=newDefaults[property]):console.error("WcTablePaginationService: setPaginationDefaults(); Property "+property+" is not a pagination default")},/**
		 * @ngdoc method
		 * @name setPaginationState
		 * @methodOf WcResponsiveTableModule.service:WcTablePaginationService
		 * @param {boolean} boolean This boolean value returns a true or false.
		 * @description
		 * This method is to set the pagination enabled option for datatable
		 */
this.setPaginationState=function(boolean){paginationEnabled=boolean}}]);